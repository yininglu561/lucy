<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ”€å²©åˆ†æä»ª iOS Pro - å†…è”æ’­æ”¾ç‰ˆ</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/pose.js"></script>
    <style>
        :root { 
            --accent: #8b5cf6; 
            --accent-light: #a78bfa;
            --success: #22c55e;
            --warning: #f59e0b;
            --danger: #ef4444;
        }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; 
            background: #000; color: #fff; margin: 0; padding: 15px; min-height: 100vh;
            -webkit-text-size-adjust: 100%;
            touch-action: manipulation; /* é˜²æ­¢åŒå‡»ç¼©æ”¾ */
        }
        .box { 
            background: #111; border: 1px solid #333; border-radius: 12px; padding: 15px; margin-bottom: 15px; text-align: center; 
        }
        .video-wrap { 
            position: relative; width: 100%; max-width: 480px; margin: 0 auto 15px; border-radius: 12px; 
            overflow: hidden; 
            /* ç§»åŠ¨ç«¯å…¼å®¹æ€§ï¼šåˆå§‹éšè—ä½†ä¿æŒå¸ƒå±€ï¼Œé¿å…è§†é¢‘ä¸åŠ è½½ */
            visibility: hidden;
            opacity: 0;
            height: 0;
            background: #000; 
            -webkit-overflow-scrolling: touch;
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
            transition: opacity 0.3s ease, height 0.3s ease;
        }
        .video-wrap.active {
            visibility: visible;
            opacity: 1;
            height: auto;
        }
        video { 
            width: 100%; height: auto; display: block; object-fit: contain;
            -webkit-playsinline: true;
            playsinline: true;
            webkit-playsinline: true;
            x5-playsinline: true;
            x5-video-player-type: h5;
            x5-video-player-fullscreen: false;
            x5-video-orientation: portrait;
            pointer-events: none; /* é˜²æ­¢iOSé»˜è®¤å…¨å± */
            background: #000;
        }
        canvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            z-index: 10;
        }
        
        .video-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
            display: flex;
            align-items: center;
            padding: 0 15px;
            z-index: 20;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .video-wrap:hover .video-controls,
        .video-wrap:active .video-controls {
            opacity: 1;
        }
        .play-btn {
            width: 40px;
            height: 40px;
            background: rgba(255,255,255,0.2);
            border-radius: 50%;
            border: none;
            color: #fff;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
        .time-display {
            margin-left: 15px;
            font-size: 14px;
            color: #fff;
        }
        
        .status-indicator {
            position: absolute; top: 15px; left: 15px; padding: 5px 12px; border-radius: 20px;
            background: rgba(0,0,0,0.6); font-size: 12px; display: flex; align-items: center; gap: 6px;
            z-index: 20;
        }
        .dot { width: 8px; height: 8px; border-radius: 50%; background: var(--success); transition: 0.3s; }

        .btn { 
            background: var(--accent); color: #fff; border: none; padding: 15px 30px; border-radius: 10px; 
            font-weight: bold; width: 100%; font-size: 16px; margin: 10px 0; cursor: pointer; transition: all 0.3s ease;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        .btn:active { transform: scale(0.98); opacity: 0.9; }
        .btn:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }

        #progress-container { 
            position: relative;
            height: 20px; 
            background: #222; 
            width: 100%; 
            margin: 10px 0; 
            border-radius: 10px; 
            display: none; 
            cursor: pointer;
            overflow: hidden;
            touch-action: none;
        }
        #progress-bar {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 4px;
            background: #333;
            transform: translateY(-50%);
            pointer-events: none;
        }
        #progress-fill { 
            height: 100%; 
            background: linear-gradient(90deg, var(--accent), var(--accent-light)); 
            width: 0%; 
            transition: width 0.1s linear;
            position: relative;
        }
        .progress-thumb {
            position: absolute;
            right: -8px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
            pointer-events: none;
        }
        .time-tooltip {
            position: absolute;
            top: -35px;
            background: rgba(0,0,0,0.9);
            color: #fff;
            padding: 5px 10px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            transform: translateX(-50%);
            white-space: nowrap;
        }
        #progress-container:hover .time-tooltip,
        #progress-container:active .time-tooltip {
            opacity: 1;
        }

        .score-card { 
            background: linear-gradient(145deg, #1a1a24, #111118); padding: 25px; border-radius: 20px; 
            display: none; border: 1px solid rgba(139, 92, 246, 0.2); box-shadow: 0 25px 50px rgba(0,0,0,0.5);
        }
        .score-header { text-align: center; margin-bottom: 25px; padding-bottom: 20px; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .score-circle {
            width: 140px; height: 140px; margin: 0 auto 15px; border-radius: 50%;
            background: conic-gradient(var(--accent) calc(var(--score) * 1%), #222 calc(var(--score) * 1%));
            display: flex; align-items: center; justify-content: center; position: relative;
        }
        .score-circle::before { content: ''; position: absolute; width: 110px; height: 110px; background: #1a1a24; border-radius: 50%; }
        .score-value { position: relative; font-size: 42px; font-weight: bold; color: var(--accent); z-index: 1; }
        
        .ai-advice {
            background: rgba(139, 92, 246, 0.1); border-left: 3px solid var(--accent);
            padding: 15px; border-radius: 0 12px 12px 0; margin-top: 20px; font-size: 14px; line-height: 1.6; text-align: left;
        }

        .metric { background: rgba(255,255,255,0.03); padding: 15px; border-radius: 12px; margin: 12px 0; }
        .metric-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .metric-name { font-size: 15px; color: #ccc; display: flex; align-items: center; gap: 8px; }
        .metric-score { font-size: 20px; font-weight: bold; color: #fff; }
        .metric-bar-bg { height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden; }
        .metric-bar-fill { height: 100%; border-radius: 3px; transition: width 1s ease-out; position: relative; overflow: hidden; }
        .metric-bar-fill::after {
            content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 2s infinite;
        }
        @keyframes shimmer { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } }
        .grade-badge {
            display: inline-block; padding: 6px 16px; border: 1px solid var(--accent);
            border-radius: 20px; font-size: 13px; color: var(--accent); font-weight: 600; margin-top: 10px;
        }
        .lock-warning { color: var(--danger); font-weight: bold; animation: blink 1s infinite; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        
        .debug-info {
            font-size: 12px; color: #666; margin-top: 10px; font-family: monospace;
            word-break: break-all;
        }
        
        .sub-metric {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
            padding-left: 10px;
            border-left: 2px solid rgba(139, 92, 246, 0.3);
        }

        /* ç§»åŠ¨ç«¯æç¤º */
        .mobile-hint {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
            padding: 10px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            display: none;
        }
        @media (max-width: 768px) {
            .mobile-hint {
                display: block;
            }
        }
    </style>
<base target="_blank">
</head>
<body>

    <div id="status" class="box">
        è¯·ä¸Šä¼ æ”€å²©åŠ¨ä½œè§†é¢‘<br>
        <span style="font-size:12px;color:#666">æ”¯æŒiOS Safariå’ŒAndroid Chrome</span>
        <div class="mobile-hint">
            ğŸ’¡ ç§»åŠ¨ç«¯æç¤ºï¼šè‹¥è§†é¢‘æ— æ³•æ˜¾ç¤ºï¼Œè¯·ç¡®ä¿å·²å…è®¸è‡ªåŠ¨æ’­æ”¾ï¼Œæˆ–å°è¯•åˆ·æ–°é¡µé¢
        </div>
    </div>

    <input type="file" id="videoInput" accept="video/*" style="display:none">
    <button class="btn" id="selectBtn" onclick="document.getElementById('videoInput').click()">ğŸ“ é€‰æ‹©è§†é¢‘</button>
    
    <!-- æ–°å¢ï¼šå…ˆæ˜¾ç¤ºè§†é¢‘è®©ç”¨æˆ·ç¡®è®¤ï¼Œå†å¼€å§‹åˆ†æ -->
    <button class="btn" id="previewBtn" style="display:none; background:var(--success);" onclick="previewVideo()">â–¶ï¸ é¢„è§ˆè§†é¢‘</button>
    <button class="btn" id="startBtn" style="display:none;" onclick="beginProcess()" disabled>ğŸš€ å¼€å§‹æ™ºèƒ½åˆ†æ</button>

    <div class="video-wrap" id="videoWrap">
        <div class="status-indicator">
            <div class="dot" id="statusDot"></div>
            <span id="statusText">å‡†å¤‡å°±ç»ª</span>
        </div>
        <!-- å¢åŠ æ‰€æœ‰ç§»åŠ¨ç«¯å…¼å®¹æ€§å±æ€§ -->
        <video id="v" 
               playsinline 
               webkit-playsinline 
               muted 
               preload="auto"
               autoplay
               x5-playsinline
               x5-video-player-type="h5"
               x5-video-player-fullscreen="false"
               x5-video-orientation="portrait"
               style="background:#000;"></video>
        <canvas id="c"></canvas>
        
        <div class="video-controls" id="videoControls">
            <button class="play-btn" id="playPauseBtn" onclick="togglePlay()">â–¶</button>
            <span class="time-display" id="timeDisplay">0:00 / 0:00</span>
        </div>
    </div>
    <div id="progress-container">
        <div id="progress-bar">
            <div id="progress-fill">
                <div class="progress-thumb"></div>
            </div>
        </div>
        <div class="time-tooltip" id="timeTooltip">00:00</div>
    </div>

    <button class="btn" id="replayBtn" style="display:none; background:#333; margin-top: 0;" onclick="resetAndPlay()">ğŸï¸ é‡æ–°æ’­æ”¾</button>

    <div class="score-card" id="scoreCard">
        <div class="score-header">
            <div class="score-circle" id="scoreCircle" style="--score: 0;">
                <div class="score-value" id="totalScore">0</div>
            </div>
            <div style="font-size: 14px; color: #888; letter-spacing: 2px;">ç»¼åˆè¡¨ç°å¾—åˆ†</div>
            <div class="grade-badge" id="gradeBadge">è®¡ç®—ä¸­...</div>
        </div>

        <div id="metrics"></div>
        <div class="debug-info" id="debugInfo"></div>

        <div class="ai-advice" id="aiAdvice">
            <b>AI è®­ç»ƒå»ºè®®ï¼š</b><br>
            æ­£åœ¨æ ¹æ®ä½ çš„åŠ¨ä½œç”Ÿæˆä¸ªæ€§åŒ–æ”¹è¿›æ–¹æ¡ˆ...
        </div>
    </div>

    <script>
        // è°ƒè¯•æ—¥å¿—å‡½æ•°
        function log(msg) {
            console.log(msg);
            const debugInfo = document.getElementById('debugInfo');
            if (debugInfo) {
                debugInfo.innerHTML += msg + '<br>';
            }
        }

        // ==================== å…¨å±€é…ç½® ====================
        const CONFIG = {
            STABLE_VELOCITY_THRESHOLD: 0.02,
            CENTER_VELOCITY_SMALL: 0.01,
            CENTER_VELOCITY_HIGH: 0.05,
            ACCELERATION_HIGH: 0.1,
            INSTABILITY_TIME_THRESHOLD: 0.3,
            PAUSE_TIME_THRESHOLD: 0.5,
            LOCK_ARM_TIME_THRESHOLD: 1.0,
            PRE_MOVEMENT_TIME: 0.3,
            
            WEIGHTS: {
                STRUCTURE: 0.30,
                CONTROL: 0.30,
                EFFICIENCY: 0.25,
                TECHNIQUE_RISK: 0.15
            },
            
            SUB_WEIGHTS: {
                THREE_POINT: 0.20,
                CONVERSION: 0.10,
                STABILITY: 0.15,
                RECOVERY: 0.15,
                FLOW: 0.15,
                PREP: 0.10,
                LOCK_ARM: 0.15
            }
        };

        // ==================== å…¨å±€å˜é‡ ====================
        const v = document.getElementById('v'), c = document.getElementById('c'), ctx = c.getContext('2d');
        const progressContainer = document.getElementById('progress-container');
        const progressFill = document.getElementById('progress-fill');
        const timeTooltip = document.getElementById('timeTooltip');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const timeDisplay = document.getElementById('timeDisplay');
        
        let pose, videoDuration = 0;
        let isAnalyzing = false;
        let isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        let isAndroid = /Android/.test(navigator.userAgent);
        
        let frameDataList = [];
        let videoMetrics = null;
        let lastFrameData = null;
        let lockArmState = { left: { startTime: null, isLocking: false }, right: { startTime: null, isLocking: false } };
        let pauseState = { startTime: null, isPausing: false };
        let instabilityState = { startTime: null, isUnstable: false };
        let supportViolationState = { startTime: null, isViolating: false };
        let isVideoReady = false;

        // ==================== æ•°æ®ç»“æ„å®šä¹‰ ====================
        
        class FrameData {
            constructor(time, landmarks) {
                this.time = time;
                this.landmarks = landmarks ? JSON.parse(JSON.stringify(landmarks)) : null;
                this.center = { x: 0, y: 0 };
                this.velocity = 0;
                this.acceleration = 0;
                this.limbVelocity = [0, 0, 0, 0];
                this.supportState = 'stable';
                this.pauseState = false;
                this.lockState = { left: false, right: false, isLocking: false };
                this.instabilityState = false;
                this.preMovementState = false;
                this.angles = {
                    leftElbow: 0, rightElbow: 0,
                    leftShoulder: 0, rightShoulder: 0
                };
                this.supportPoints = 0;
                this.movingLimbs = 0;
            }
        }
        
        class VideoMetrics {
            constructor() {
                this.totalFrames = 0;
                this.totalDuration = 0;
                this.stableFrames = 0;
                this.briefUnstableFrames = 0;
                this.unstableFrames = 0;
                this.supportViolationFrames = 0;
                this.conversionViolations = 0;
                this.instabilityFrames = 0;
                this.recoveryTimes = [];
                this.pauseCount = 0;
                this.totalPauseDuration = 0;
                this.movementCount = 0;
                this.noPrepCount = 0;
                this.lockDuration = { left: 0, right: 0, total: 0 };
                this.lockEvents = [];
            }
        }

        // ==================== ç§»åŠ¨ç«¯å…¼å®¹æ€§è®¾ç½® ====================
        
        function setupMobileVideo() {
            log(`è®¾å¤‡æ£€æµ‹: iOS=${isIOS}, Android=${isAndroid}`);
            
            // å¼ºåˆ¶è®¾ç½®æ‰€æœ‰ç§»åŠ¨ç«¯å±æ€§
            v.setAttribute('playsinline', 'true');
            v.setAttribute('webkit-playsinline', 'true');
            v.setAttribute('x5-playsinline', 'true');
            v.setAttribute('x5-video-player-type', 'h5');
            v.setAttribute('x5-video-player-fullscreen', 'false');
            v.setAttribute('x5-video-orientation', 'portrait');
            v.setAttribute('muted', 'true');
            v.setAttribute('preload', 'auto');
            
            // iOSç‰¹æ®Šå¤„ç†
            if (isIOS) {
                v.style.objectFit = 'contain';
                v.style.width = '100%';
                v.style.height = 'auto';
            }
            
            // ç›‘å¬è§†é¢‘äº‹ä»¶
            v.addEventListener('loadedmetadata', () => {
                log('è§†é¢‘å…ƒæ•°æ®åŠ è½½å®Œæˆ');
                videoDuration = v.duration;
                updateTimeDisplay();
            });
            
            v.addEventListener('canplay', () => {
                log('è§†é¢‘å¯ä»¥æ’­æ”¾');
                isVideoReady = true;
                document.getElementById('startBtn').disabled = false;
            });
            
            v.addEventListener('error', (e) => {
                log(`è§†é¢‘é”™è¯¯: ${e.message || 'æœªçŸ¥é”™è¯¯'}`);
                alert('è§†é¢‘åŠ è½½å¤±è´¥ï¼Œè¯·å°è¯•å…¶ä»–è§†é¢‘æ ¼å¼');
            });
            
            // ç¡®ä¿é™éŸ³ï¼ˆè‡ªåŠ¨æ’­æ”¾è¦æ±‚ï¼‰
            v.muted = true;
            v.volume = 0;
        }

        function togglePlay() {
            if (v.paused) {
                v.play().then(() => {
                    playPauseBtn.innerText = 'â¸';
                    log('æ’­æ”¾æˆåŠŸ');
                }).catch(e => {
                    log(`æ’­æ”¾å¤±è´¥: ${e.message}`);
                    // å°è¯•é™éŸ³åæ’­æ”¾
                    v.muted = true;
                    v.play().then(() => {
                        playPauseBtn.innerText = 'â¸';
                    }).catch(e2 => {
                        alert('è¯·ç‚¹å‡»è§†é¢‘åŒºåŸŸæ‰‹åŠ¨æ’­æ”¾');
                    });
                });
            } else {
                v.pause();
                playPauseBtn.innerText = 'â–¶';
            }
        }

        function resetAndPlay() {
            v.currentTime = 0;
            togglePlay();
        }

        function updateTimeDisplay() {
            const current = formatTime(v.currentTime);
            const total = formatTime(videoDuration);
            timeDisplay.innerText = `${current} / ${total}`;
        }

        function formatTime(seconds) {
            if (!seconds || isNaN(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        v.addEventListener('timeupdate', () => {
            updateTimeDisplay();
            if (!isAnalyzing && frameDataList.length > 0) {
                const frame = frameDataList.find(f => Math.abs(f.time - v.currentTime) < 0.25);
                if (frame) {
                    draw(frame);
                    updateStatusIndicator(frame);
                    const percent = (v.currentTime / videoDuration) * 100;
                    progressFill.style.width = percent + '%';
                }
            }
        });

        v.addEventListener('ended', () => {
            playPauseBtn.innerText = 'â–¶';
        });

        // ==================== åŸºç¡€è¿åŠ¨å‚æ•°è®¡ç®—å±‚ ====================
        
        function computeLimbVelocity(current, previous, dt) {
            if (!previous || dt <= 0) return [0, 0, 0, 0];
            
            const velocities = [];
            const limbIndices = [15, 16, 27, 28];
            
            for (let idx of limbIndices) {
                const curr = current[idx];
                const prev = previous[idx];
                if (curr && prev && curr.visibility > 0.5 && prev.visibility > 0.5) {
                    const dx = curr.x - prev.x;
                    const dy = curr.y - prev.y;
                    const velocity = Math.sqrt(dx*dx + dy*dy) / dt;
                    velocities.push(velocity);
                } else {
                    velocities.push(0);
                }
            }
            
            return velocities;
        }
        
        function computeCenterVelocity(currentCenter, previousCenter, dt) {
            if (!previousCenter || dt <= 0) return 0;
            const dx = currentCenter.x - previousCenter.x;
            const dy = currentCenter.y - previousCenter.y;
            return Math.sqrt(dx*dx + dy*dy) / dt;
        }
        
        function computeAcceleration(currentVelocity, previousVelocity, dt) {
            if (!previousVelocity || dt <= 0) return 0;
            return Math.abs(currentVelocity - previousVelocity) / dt;
        }
        
        function getAngle(p1, p2, p3) {
            const rad = Math.atan2(p3.y - p2.y, p3.x - p2.x) - Math.atan2(p1.y - p2.y, p1.x - p2.x);
            let angle = Math.abs(rad * 180 / Math.PI);
            return angle > 180 ? 360 - angle : angle;
        }

        // ==================== è¡Œä¸ºè¯†åˆ«å±‚ ====================
        
        function detectThreePointSupport(frame, prevFrame) {
            let stablePoints = 0;
            let movingLimbs = 0;
            
            for (let i = 0; i < 4; i++) {
                if (frame.limbVelocity[i] < CONFIG.STABLE_VELOCITY_THRESHOLD) {
                    stablePoints++;
                } else {
                    movingLimbs++;
                }
            }
            
            frame.supportPoints = stablePoints;
            frame.movingLimbs = movingLimbs;
            
            const handsMoving = (frame.limbVelocity[0] > CONFIG.STABLE_VELOCITY_THRESHOLD && 
                               frame.limbVelocity[1] > CONFIG.STABLE_VELOCITY_THRESHOLD);
            
            if (stablePoints >= 3) {
                frame.supportState = 'stable';
            } else {
                frame.supportState = 'unstable';
            }
            
            return { stablePoints, handsMoving, isViolation: stablePoints < 3 };
        }
        
        function detectInstability(frame, prevFrame) {
            const isHighAccel = frame.acceleration > CONFIG.ACCELERATION_HIGH;
            const isHighVel = frame.velocity > CONFIG.CENTER_VELOCITY_HIGH;
            frame.instabilityState = isHighAccel && !isHighVel;
            return frame.instabilityState;
        }
        
        function detectPause(frame, prevFrame) {
            const isLowVel = frame.velocity < CONFIG.CENTER_VELOCITY_SMALL;
            return isLowVel;
        }
        
        function detectPreMovement(currentFrame, frameHistory) {
            if (!currentFrame || frameHistory.length < 3) return false;
            
            const movingLimbs = [];
            for (let i = 0; i < 4; i++) {
                if (currentFrame.limbVelocity[i] > CONFIG.STABLE_VELOCITY_THRESHOLD) {
                    movingLimbs.push(i);
                }
            }
            
            if (movingLimbs.length === 0) return false;
            
            const preTime = currentFrame.time - CONFIG.PRE_MOVEMENT_TIME;
            const preFrame = frameHistory.find(f => Math.abs(f.time - preTime) < 0.1);
            
            if (!preFrame) return false;
            
            const dx = currentFrame.center.x - preFrame.center.x;
            const dy = currentFrame.center.y - preFrame.center.y;
            const preMovement = Math.sqrt(dx*dx + dy*dy) > 0.01;
            
            currentFrame.preMovementState = preMovement;
            return preMovement;
        }
        
        function detectLockArm(frame) {
            if (!frame.landmarks) return { left: false, right: false };
            
            const lm = frame.landmarks;
            
            frame.angles.leftElbow = getAngle(lm[11], lm[13], lm[15]);
            frame.angles.rightElbow = getAngle(lm[12], lm[14], lm[16]);
            frame.angles.leftShoulder = getAngle(lm[23], lm[11], lm[13]);
            frame.angles.rightShoulder = getAngle(lm[24], lm[12], lm[14]);
            
            const isLeftLocking = frame.angles.leftElbow < 90 && frame.angles.leftShoulder < 120;
            const isRightLocking = frame.angles.rightElbow < 90 && frame.angles.rightShoulder < 120;
            
            let isRising = false;
            if (lastFrameData) {
                const dy = lastFrameData.center.y - frame.center.y;
                isRising = dy > 0.02;
            }
            
            frame.lockState.left = isLeftLocking && !isRising;
            frame.lockState.right = isRightLocking && !isRising;
            frame.lockState.isLocking = frame.lockState.left || frame.lockState.right;
            
            return frame.lockState;
        }

        // ==================== æ—¶é—´èšåˆå±‚ ====================
        
        function aggregateTimeMetrics(frames, duration) {
            const metrics = new VideoMetrics();
            metrics.totalFrames = frames.length;
            metrics.totalDuration = duration;
            
            let unstableStartTime = null;
            let pauseStartTime = null;
            let lockStartTime = { left: null, right: null };
            let lastHandsMovingTime = null;
            let recoveryStartTime = null;
            
            for (let i = 0; i < frames.length; i++) {
                const frame = frames[i];
                const nextFrame = i < frames.length - 1 ? frames[i+1] : null;
                const dt = nextFrame ? (nextFrame.time - frame.time) : 0.1;
                
                if (frame.supportState === 'stable') {
                    metrics.stableFrames++;
                    unstableStartTime = null;
                } else {
                    if (!unstableStartTime) unstableStartTime = frame.time;
                    const unstableDuration = frame.time - unstableStartTime;
                    
                    if (unstableDuration < CONFIG.INSTABILITY_TIME_THRESHOLD) {
                        metrics.briefUnstableFrames++;
                    } else {
                        metrics.unstableFrames++;
                    }
                }
                
                if (frame.movingLimbs >= 2) {
                    if (!lastHandsMovingTime || (frame.time - lastHandsMovingTime) > 0.5) {
                        metrics.conversionViolations++;
                        metrics.supportViolationFrames++;
                        lastHandsMovingTime = frame.time;
                    }
                }
                
                if (frame.instabilityState) {
                    metrics.instabilityFrames++;
                    if (!recoveryStartTime) recoveryStartTime = frame.time;
                } else {
                    if (recoveryStartTime) {
                        const recoveryTime = frame.time - recoveryStartTime;
                        metrics.recoveryTimes.push(recoveryTime);
                        recoveryStartTime = null;
                    }
                }
                
                const isLowVel = frame.velocity < CONFIG.CENTER_VELOCITY_SMALL;
                if (isLowVel) {
                    if (!pauseStartTime) pauseStartTime = frame.time;
                    const pauseDuration = frame.time - pauseStartTime;
                    if (pauseDuration >= CONFIG.PAUSE_TIME_THRESHOLD && !frame.pauseState) {
                        frame.pauseState = true;
                        metrics.pauseCount++;
                        metrics.totalPauseDuration += pauseDuration;
                    }
                } else {
                    pauseStartTime = null;
                }
                
                ['left', 'right'].forEach(side => {
                    if (frame.lockState[side]) {
                        if (!lockStartTime[side]) lockStartTime[side] = frame.time;
                        const lockDuration = frame.time - lockStartTime[side];
                        
                        if (lockDuration >= CONFIG.LOCK_ARM_TIME_THRESHOLD) {
                            metrics.lockDuration[side] += dt;
                            metrics.lockDuration.total += dt;
                            if (!frame.lockState.isLocking) frame.lockState.isLocking = true;
                        }
                    } else {
                        if (lockStartTime[side]) {
                            const duration = frame.time - lockStartTime[side];
                            if (duration >= CONFIG.LOCK_ARM_TIME_THRESHOLD) {
                                metrics.lockEvents.push({ side, duration, time: lockStartTime[side] });
                            }
                            lockStartTime[side] = null;
                        }
                    }
                });
                
                if (i > 5) {
                    const history = frames.slice(Math.max(0, i-10), i);
                    const hasPrep = detectPreMovement(frame, history);
                    if (frame.movingLimbs > 0) {
                        metrics.movementCount++;
                        if (!hasPrep) metrics.noPrepCount++;
                    }
                }
            }
            
            return metrics;
        }

        // ==================== è¯„åˆ†è®¡ç®—å±‚ ====================
        
        function calculateScores(metrics) {
            const scores = {};
            const totalFrames = metrics.totalFrames || 1;
            
            const threePointScore = ((metrics.stableFrames + 0.5 * metrics.briefUnstableFrames) / totalFrames) * 100;
            const violationRatio = metrics.supportViolationFrames / totalFrames;
            const conversionScore = 100 * (1 - violationRatio);
            
            scores.structure = {
                total: threePointScore * (CONFIG.SUB_WEIGHTS.THREE_POINT / 0.30) + 
                       conversionScore * (CONFIG.SUB_WEIGHTS.CONVERSION / 0.30),
                threePoint: Math.round(threePointScore),
                conversion: Math.round(conversionScore)
            };
            
            const instabilityRatio = metrics.instabilityFrames / totalFrames;
            const stabilityScore = 100 * (1 - instabilityRatio);
            
            let recoveryScore = 100;
            if (metrics.recoveryTimes.length > 0) {
                const avgRecovery = metrics.recoveryTimes.reduce((a,b) => a+b, 0) / metrics.recoveryTimes.length;
                recoveryScore = Math.max(0, 100 - avgRecovery * 50);
            }
            
            scores.control = {
                total: stabilityScore * (CONFIG.SUB_WEIGHTS.STABILITY / 0.30) + 
                       recoveryScore * (CONFIG.SUB_WEIGHTS.RECOVERY / 0.30),
                stability: Math.round(stabilityScore),
                recovery: Math.round(recoveryScore)
            };
            
            const flowScore = Math.max(0, Math.min(100, 100 - 15 * metrics.pauseCount));
            
            let prepScore = 100;
            if (metrics.movementCount > 0) {
                const noPrepRatio = metrics.noPrepCount / metrics.movementCount;
                prepScore = 100 * (1 - noPrepRatio);
            }
            
            scores.efficiency = {
                total: flowScore * (CONFIG.SUB_WEIGHTS.FLOW / 0.25) + 
                       prepScore * (CONFIG.SUB_WEIGHTS.PREP / 0.25),
                flow: Math.round(flowScore),
                prep: Math.round(prepScore)
            };
            
            const lockRatio = metrics.lockDuration.total / (metrics.totalDuration || 1);
            const lockScore = 100 * (1 - Math.pow(lockRatio, 2));
            
            scores.techniqueRisk = {
                total: lockScore,
                lockArm: Math.round(lockScore)
            };
            
            const totalScore = 
                scores.structure.total * CONFIG.WEIGHTS.STRUCTURE +
                scores.control.total * CONFIG.WEIGHTS.CONTROL +
                scores.efficiency.total * CONFIG.WEIGHTS.EFFICIENCY +
                scores.techniqueRisk.total * CONFIG.WEIGHTS.TECHNIQUE_RISK;
            
            return {
                total: Math.round(totalScore),
                structure: scores.structure,
                control: scores.control,
                efficiency: scores.efficiency,
                techniqueRisk: scores.techniqueRisk,
                metrics: metrics
            };
        }

        // ==================== å»ºè®®ç”Ÿæˆå±‚ ====================
        
        function generateAdvice(results) {
            const s = results.structure;
            const ctrl = results.control;
            const eff = results.efficiency;
            const tech = results.techniqueRisk;
            const total = results.total;
            const m = results.metrics;
            
            let advice = [];
            let grade = '';
            let gradeColor = '';
            
            if (total >= 90) {
                grade = 'S';
                gradeColor = 'var(--success)';
                advice.push("ä½ çš„åŠ¨ä½œéå¸¸è€ç»ƒï¼ä¸‰ç‚¹ä¸åŠ¨åŸåˆ™è´¯å½»å¾—å¾ˆå½»åº•ï¼Œä¸”å¾ˆå°‘å‡ºç°é”è‡‚ã€‚");
            } else if (total >= 80) {
                grade = 'A';
                gradeColor = 'var(--accent)';
                advice.push("è¡¨ç°ä¸é”™ï¼Œæ•´ä½“åŠ¨ä½œæµç•…ï¼Œä½†åœ¨æŸäº›ç»†èŠ‚ä¸Šè¿˜æœ‰æå‡ç©ºé—´ã€‚");
            } else if (total >= 65) {
                grade = 'B';
                gradeColor = 'var(--warning)';
                advice.push("åŸºç¡€æ¯”è¾ƒæ‰å®ï¼Œä½†éœ€è¦é’ˆå¯¹æ€§æ”¹è¿›ä¸€äº›æŠ€æœ¯ç»†èŠ‚ã€‚");
            } else {
                grade = 'C';
                gradeColor = 'var(--danger)';
                advice.push("æ£€æµ‹åˆ°è¾ƒå¤šæŠ€æœ¯é—®é¢˜ï¼Œå»ºè®®é‡ç‚¹ç»ƒä¹ åŸºç¡€åŠ¨ä½œæ¨¡å¼ã€‚");
            }
            
            const weaknesses = [];
            
            if (s.threePoint < 70) {
                weaknesses.push(`ä¸‰ç‚¹æ”¯æ’‘ç¨³å®šåº¦ä¸è¶³ï¼ˆ${s.threePoint}åˆ†ï¼‰`);
                advice.push("å»ºè®®ï¼šå§‹ç»ˆä¿æŒè‡³å°‘3ä¸ªè‚¢ä½“ç¨³å®šæ¥è§¦å²©å£ï¼Œç§»åŠ¨å•è‚¢æ—¶ç¡®ä¿å…¶ä»–3ç‚¹ç‰¢å›ºã€‚");
            }
            
            if (s.conversion < 80) {
                weaknesses.push(`æ”¯æ’‘è½¬æ¢è¿è§„${m.conversionViolations}æ¬¡`);
                advice.push("å»ºè®®ï¼šé¿å…åŒæ‰‹åŒæ—¶ç¦»å¼€å²©ç‚¹ï¼Œé‡‡ç”¨'ä¸‰ç‚¹ä¸åŠ¨ä¸€ç‚¹åŠ¨'åŸåˆ™è¿›è¡Œæ¢ç‚¹ã€‚");
            }
            
            if (ctrl.stability < 70) {
                weaknesses.push(`é‡å¿ƒæ§åˆ¶ä¸ç¨³ï¼ˆ${ctrl.stability}åˆ†ï¼‰`);
                advice.push("å»ºè®®ï¼šé€šè¿‡è…¿éƒ¨å‘åŠ›è€Œéæ‰‹è‡‚æ‹‰æ‹½æ¥æ§åˆ¶é‡å¿ƒç§»åŠ¨ï¼Œä¿æŒæ ¸å¿ƒæ”¶ç´§ã€‚");
            }
            
            if (ctrl.recovery < 70 && m.recoveryTimes.length > 0) {
                const avgRec = (m.recoveryTimes.reduce((a,b)=>a+b,0)/m.recoveryTimes.length).toFixed(2);
                weaknesses.push(`å¤±è¡¡æ¢å¤è¾ƒæ…¢ï¼Œå¹³å‡${avgRec}ç§’`);
                advice.push("å»ºè®®ï¼šæå‰é¢„åˆ¤é‡å¿ƒåç§»ï¼Œåˆ©ç”¨åä½œç”¨åŠ›å¿«é€Ÿè°ƒæ•´å§¿æ€ã€‚");
            }
            
            if (eff.flow < 70) {
                weaknesses.push(`åŠ¨ä½œæµç•…åº¦ä¸è¶³ï¼ˆ${eff.flow}åˆ†ï¼‰ï¼Œåœé¡¿${m.pauseCount}æ¬¡`);
                advice.push("å»ºè®®ï¼šå‡å°‘ä¸å¿…è¦çš„åœé¡¿ï¼Œæå‰è§„åˆ’å¥½è·¯çº¿ï¼Œä¿æŒåŠ¨ä½œè¿è´¯æ€§ã€‚");
            }
            
            if (eff.prep < 70 && m.movementCount > 0) {
                const prepRate = ((1 - m.noPrepCount/m.movementCount) * 100).toFixed(0);
                weaknesses.push(`é‡å¿ƒé¢„æ‘†æ„è¯†ä¸è¶³ï¼ˆ${prepRate}%æœ‰é¢„æ‘†ï¼‰`);
                advice.push("å»ºè®®ï¼šåœ¨æ‰‹éƒ¨ç§»åŠ¨å‰0.3ç§’ï¼Œæå‰å°†é‡å¿ƒæœç›®æ ‡æ–¹å‘åç§»ï¼Œåˆ©ç”¨åŠ¨é‡è¾…åŠ©ç§»åŠ¨ã€‚");
            }
            
            if (tech.lockArm < 70) {
                const lockSec = m.lockDuration.total.toFixed(1);
                weaknesses.push(`é”è‡‚é—®é¢˜ä¸¥é‡ï¼ˆ${tech.lockArm}åˆ†ï¼‰ï¼Œç´¯è®¡${lockSec}ç§’`);
                advice.push(`å»ºè®®ï¼šæ‰‹è‡‚ä¿æŒè‡ªç„¶ä¼¸ç›´ï¼ˆè‚˜è§’>90Â°ï¼‰ï¼Œé€šè¿‡è…¿éƒ¨æ¨ªå‘ç§»åŠ¨å‘åŠ›ã€‚æ£€æµ‹åˆ°${m.lockEvents.length}æ¬¡é”è‡‚äº‹ä»¶ã€‚`);
            }
            
            if (weaknesses.length === 0) {
                advice.push("å„é¡¹æŠ€æœ¯æŒ‡æ ‡è¡¨ç°å‡è¡¡ï¼Œå»ºè®®ä¿æŒå½“å‰è®­ç»ƒèŠ‚å¥ï¼Œå°è¯•æé«˜åŠ¨ä½œéš¾åº¦ã€‚");
            }
            
            return {
                grade,
                gradeColor,
                text: advice.join('<br><br>'),
                weaknesses
            };
        }

        // ==================== æ–‡ä»¶é€‰æ‹©å’Œé¢„è§ˆ ====================
        
        document.getElementById('videoInput').onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            log(`é€‰æ‹©æ–‡ä»¶: ${file.name}, å¤§å°: ${(file.size/1024/1024).toFixed(2)}MB`);
            
            setupMobileVideo();
            
            const url = URL.createObjectURL(file);
            v.src = url;
            v.load();
            
            // æ˜¾ç¤ºé¢„è§ˆæŒ‰é’®ï¼Œéšè—é€‰æ‹©æŒ‰é’®
            document.getElementById('selectBtn').style.display = 'none';
            document.getElementById('previewBtn').style.display = 'block';
            document.getElementById('status').innerHTML = "è§†é¢‘å·²é€‰æ‹©<br><span style='font-size:12px;color:#666'>ç‚¹å‡»é¢„è§ˆè§†é¢‘ç¡®è®¤åŠ è½½</span>";
        };

        // æ–°å¢ï¼šé¢„è§ˆè§†é¢‘åŠŸèƒ½ï¼ˆè§£å†³ç§»åŠ¨ç«¯è‡ªåŠ¨æ’­æ”¾é™åˆ¶ï¼‰
        async function previewVideo() {
            log('å¼€å§‹é¢„è§ˆè§†é¢‘...');
            
            const videoWrap = document.getElementById('videoWrap');
            videoWrap.classList.add('active');
            
            // å°è¯•æ’­æ”¾ï¼ˆå¿…é¡»ç”±ç”¨æˆ·ç‚¹å‡»è§¦å‘ï¼‰
            try {
                v.muted = true;
                await v.play();
                log('è§†é¢‘æ’­æ”¾æˆåŠŸ');
                
                // æ˜¾ç¤ºå¼€å§‹åˆ†ææŒ‰é’®
                document.getElementById('previewBtn').style.display = 'none';
                document.getElementById('startBtn').style.display = 'block';
                document.getElementById('startBtn').disabled = false;
                document.getElementById('status').innerHTML = "è§†é¢‘é¢„è§ˆä¸­<br><span style='font-size:12px;color:#666'>ç¡®è®¤è§†é¢‘æ­£å¸¸æ’­æ”¾åï¼Œç‚¹å‡»å¼€å§‹åˆ†æ</span>";
                
            } catch (err) {
                log(`æ’­æ”¾å¤±è´¥: ${err.message}`);
                alert('è¯·æ‰‹åŠ¨ç‚¹å‡»è§†é¢‘æ’­æ”¾æŒ‰é’®ï¼Œç„¶åå†å¼€å§‹åˆ†æ');
                
                // ä»ç„¶æ˜¾ç¤ºå¼€å§‹åˆ†ææŒ‰é’®ï¼Œä½†æé†’ç”¨æˆ·
                document.getElementById('previewBtn').style.display = 'none';
                document.getElementById('startBtn').style.display = 'block';
                document.getElementById('status').innerHTML = "è¯·æ‰‹åŠ¨æ’­æ”¾è§†é¢‘<br><span style='font-size:12px;color:#666'>ç‚¹å‡»è§†é¢‘æ’­æ”¾åï¼Œå†å¼€å§‹åˆ†æ</span>";
            }
        }

        // ==================== MediaPipeåˆå§‹åŒ– ====================
        
        function initPose() {
            if (pose) return Promise.resolve();
            
            return new Promise((resolve, reject) => {
                try {
                    pose = new Pose({ 
                        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/${file}` 
                    });
                    
                    pose.setOptions({ 
                        modelComplexity: isIOS ? 0 : 1,
                        smoothLandmarks: true, 
                        minDetectionConfidence: 0.3,
                        minTrackingConfidence: 0.3
                    });
                    
                    pose.onResults(res => {
                        if (!res.poseLandmarks || isAnalyzing) return;
                        
                        const lm = res.poseLandmarks;
                        const currentTime = v.currentTime;
                        
                        const frame = new FrameData(currentTime, lm);
                        
                        if (lm[23] && lm[24]) {
                            frame.center.x = (lm[23].x + lm[24].x) / 2;
                            frame.center.y = (lm[23].y + lm[24].y) / 2;
                        }
                        
                        let dt = 0.1;
                        if (lastFrameData) {
                            dt = currentTime - lastFrameData.time;
                            if (dt <= 0) dt = 0.1;
                        }
                        
                        frame.limbVelocity = computeLimbVelocity(lm, lastFrameData ? lastFrameData.landmarks : null, dt);
                        frame.velocity = computeCenterVelocity(frame.center, lastFrameData ? lastFrameData.center : null, dt);
                        frame.acceleration = computeAcceleration(frame.velocity, lastFrameData ? lastFrameData.velocity : null, dt);
                        
                        detectThreePointSupport(frame, lastFrameData);
                        detectInstability(frame, lastFrameData);
                        detectLockArm(frame);
                        
                        frameDataList.push(frame);
                        lastFrameData = frame;
                    });
                    
                    log('MediaPipeåˆå§‹åŒ–æˆåŠŸ');
                    resolve();
                } catch (e) {
                    log(`MediaPipeåˆå§‹åŒ–å¤±è´¥: ${e.message}`);
                    reject(e);
                }
            });
        }

        // ==================== ä¸»åˆ†ææµç¨‹ ====================
        
        async function beginProcess() {
            log('å¼€å§‹åˆ†ææµç¨‹...');
            
            if (!isVideoReady) {
                alert('è§†é¢‘å°šæœªå‡†å¤‡å¥½ï¼Œè¯·ç¨ç­‰æˆ–åˆ·æ–°é¡µé¢é‡è¯•');
                return;
            }
            
            document.getElementById('startBtn').style.display = 'none';
            progressContainer.style.display = 'block';
            isAnalyzing = true;
            
            // é‡ç½®æ•°æ®
            frameDataList = [];
            lastFrameData = null;
            videoMetrics = null;
            
            // æš‚åœè§†é¢‘å¹¶é‡ç½®
            v.pause();
            v.currentTime = 0;
            
            // ç­‰å¾…MediaPipeåˆå§‹åŒ–
            try {
                await initPose();
            } catch (e) {
                alert('AIæ¨¡å‹åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
                return;
            }
            
            if (v.readyState < 2) {
                log('ç­‰å¾…è§†é¢‘æ•°æ®...');
                await new Promise(resolve => {
                    v.onloadeddata = resolve;
                    setTimeout(resolve, 2000); // è¶…æ—¶2ç§’
                });
            }
            
            videoDuration = v.duration;
            updateTimeDisplay();
            
            if (!videoDuration || isNaN(videoDuration)) {
                alert('æ— æ³•è¯»å–è§†é¢‘æ—¶é•¿ï¼Œè¯·å°è¯•å…¶ä»–è§†é¢‘');
                return;
            }
            
            log(`è§†é¢‘æ—¶é•¿: ${videoDuration.toFixed(1)}ç§’`);
            
            const step = isIOS ? 0.3 : 0.2;
            c.width = v.videoWidth || 640;
            c.height = v.videoHeight || 480;

            let processedFrames = 0;
            let errorCount = 0;
            
            // é€å¸§åˆ†æ
            for (let t = 0; t < videoDuration; t += step) {
                v.currentTime = t;
                
                // ç­‰å¾…seekå®Œæˆ
                await new Promise(resolve => {
                    let resolved = false;
                    const checkSeek = () => {
                        if (Math.abs(v.currentTime - t) < 0.1) {
                            if (!resolved) {
                                resolved = true;
                                resolve();
                            }
                        } else {
                            setTimeout(checkSeek, 50);
                        }
                    };
                    
                    const timeout = setTimeout(() => {
                        if (!resolved) {
                            resolved = true;
                            resolve();
                        }
                    }, 1500); // å¢åŠ è¶…æ—¶æ—¶é—´
                    
                    v.onseeked = () => {
                        clearTimeout(timeout);
                        checkSeek();
                    };
                });
                
                // å‘é€ç»™MediaPipe
                try {
                    await pose.send({ image: v });
                    processedFrames++;
                } catch(e) {
                    errorCount++;
                    if (errorCount > 10) {
                        log('è¿‡å¤šé”™è¯¯ï¼Œåœæ­¢åˆ†æ');
                        break;
                    }
                }
                
                // æ›´æ–°è¿›åº¦
                const prog = Math.min(100, Math.round((t/videoDuration)*100));
                progressFill.style.width = prog + '%';
                document.getElementById('status').innerText = `åˆ†æä¸­ ${prog}%`;
                
                // è®©å‡ºæ—¶é—´ç»™UIæ›´æ–°
                if (processedFrames % 5 === 0) {
                    await new Promise(r => setTimeout(r, 1));
                }
            }
            
            isAnalyzing = false;
            
            log(`åˆ†æå®Œæˆ: æ€»å¸§${frameDataList.length}, å¤„ç†${processedFrames}, é”™è¯¯${errorCount}`);
            document.getElementById('debugInfo').innerText = 
                `å¸§æ•°:${frameDataList.length}|å¤„ç†:${processedFrames}|é”™è¯¯:${errorCount}|æ—¶é•¿:${videoDuration.toFixed(1)}s`;
            
            if (frameDataList.length === 0) {
                alert('æœªæ£€æµ‹åˆ°å§¿æ€ï¼Œè¯·ç¡®ä¿è§†é¢‘ä¸­æœ‰äººç‰©å…¨èº«å‡ºé•œï¼Œä¸”å…‰çº¿å……è¶³');
                return;
            }
            
            // è®¡ç®—è¯„åˆ†
            videoMetrics = aggregateTimeMetrics(frameDataList, videoDuration);
            const results = calculateScores(videoMetrics);
            finish(results);
        }

        // ==================== è¿›åº¦æ¡äº¤äº’ ====================
        
        function handleProgressClick(e) {
            if (!videoDuration || frameDataList.length === 0) return;
            
            const rect = progressContainer.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const x = Math.max(0, Math.min(clientX - rect.left, rect.width));
            const percent = x / rect.width;
            const time = percent * videoDuration;
            
            v.currentTime = time;
            
            const mins = Math.floor(time / 60);
            const secs = Math.floor(time % 60);
            timeTooltip.textContent = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            timeTooltip.style.left = `${x}px`;
            
            const frame = frameDataList.reduce((prev, curr) => 
                Math.abs(curr.time - time) < Math.abs(prev.time - time) ? curr : prev
            );
            
            if (frame) {
                draw(frame);
                updateStatusIndicator(frame);
            }
        }

        progressContainer.addEventListener('click', handleProgressClick);
        progressContainer.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleProgressClick(e);
            progressContainer.addEventListener('touchmove', handleProgressClick);
        }, {passive: false});
        progressContainer.addEventListener('touchend', () => {
            progressContainer.removeEventListener('touchmove', handleProgressClick);
        });

        function updateStatusIndicator(frame) {
            const isViolation = frame.supportState !== 'stable';
            const isLocked = frame.lockState.isLocking;
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            
            if (isLocked) {
                statusDot.style.background = 'var(--danger)';
                statusText.innerText = 'âš ï¸ æ— æ•ˆé”è‡‚';
            } else if (isViolation) {
                statusDot.style.background = 'var(--danger)';
                statusText.innerText = 'éä¸‰ç‚¹æ”¯æ’‘!';
            } else if (frame.instabilityState) {
                statusDot.style.background = 'var(--warning)';
                statusText.innerText = 'é‡å¿ƒä¸ç¨³';
            } else {
                statusDot.style.background = 'var(--success)';
                statusText.innerText = 'å§¿æ€é«˜æ•ˆ';
            }
        }

        // ==================== ç»˜åˆ¶å‡½æ•° ====================
        
        function draw(frame) {
            ctx.clearRect(0, 0, c.width, c.height);
            
            if (!frame.landmarks) return;
            
            const lm = frame.landmarks;
            
            let strokeColor = '#8b5cf6';
            if (frame.lockState.isLocking) strokeColor = 'var(--danger)';
            else if (frame.supportState !== 'stable') strokeColor = 'var(--warning)';
            else if (frame.instabilityState) strokeColor = '#f59e0b';
            
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = Math.max(3, c.width/120); 
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            const conn = [
                [11,13],[13,15],[12,14],[14,16],
                [11,12],[11,23],[12,24],[23,24],
                [23,25],[24,26],[25,27],[26,28]
            ];
            
            conn.forEach(([s, e]) => {
                const p1 = lm[s], p2 = lm[e];
                if (p1 && p2 && p1.visibility > 0.5 && p2.visibility > 0.5) {
                    ctx.beginPath(); 
                    ctx.moveTo(p1.x*c.width, p1.y*c.height); 
                    ctx.lineTo(p2.x*c.width, p2.y*c.height); 
                    ctx.stroke();
                }
            });

            const keyPoints = [11, 12, 13, 14, 15, 16, 23, 24, 25, 26, 27, 28];
            keyPoints.forEach(idx => {
                const p = lm[idx];
                if (p && p.visibility > 0.5) {
                    ctx.beginPath();
                    ctx.arc(p.x*c.width, p.y*c.height, Math.max(4, c.width/80), 0, 2*Math.PI);
                    ctx.fillStyle = '#fff';
                    ctx.fill();
                }
            });

            if (frame.center) {
                const cx = frame.center.x * c.width;
                const cy = frame.center.y * c.height;
                
                ctx.beginPath();
                ctx.arc(cx, cy, Math.max(10, c.width/40), 0, 2*Math.PI);
                ctx.fillStyle = 'rgba(6, 182, 212, 0.3)';
                ctx.fill();
                ctx.strokeStyle = '#06b6d4';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(cx, cy, Math.max(5, c.width/80), 0, 2*Math.PI);
                ctx.fillStyle = '#06b6d4';
                ctx.fill();
                
                const crossSize = Math.max(15, c.width/30);
                ctx.beginPath();
                ctx.moveTo(cx - crossSize, cy);
                ctx.lineTo(cx + crossSize, cy);
                ctx.moveTo(cx, cy - crossSize);
                ctx.lineTo(cx, cy + crossSize);
                ctx.strokeStyle = '#06b6d4';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            if (frame.angles) {
                ctx.font = `bold ${Math.max(12, c.width/40)}px Arial`;
                ctx.textAlign = 'center';
                ctx.shadowColor = 'rgba(0,0,0,0.9)';
                ctx.shadowBlur = 4;
                
                const leftElbow = lm[13];
                if (leftElbow && leftElbow.visibility > 0.5) {
                    const isWarning = frame.lockState.left;
                    ctx.fillStyle = isWarning ? 'var(--danger)' : '#fff';
                    ctx.fillText(`${Math.round(frame.angles.leftElbow)}Â°`, leftElbow.x*c.width, leftElbow.y*c.height - 35);
                }
                
                const rightElbow = lm[14];
                if (rightElbow && rightElbow.visibility > 0.5) {
                    const isWarning = frame.lockState.right;
                    ctx.fillStyle = isWarning ? 'var(--danger)' : '#fff';
                    ctx.fillText(`${Math.round(frame.angles.rightElbow)}Â°`, rightElbow.x*c.width, rightElbow.y*c.height - 35);
                }
                
                ctx.shadowBlur = 0;
            }

            if (frame.lockState.isLocking) {
                ctx.fillStyle = 'var(--danger)';
                ctx.font = `bold ${Math.max(20, c.width/20)}px Arial`;
                ctx.textAlign = 'left';
                ctx.shadowColor = 'rgba(0,0,0,0.9)';
                ctx.shadowBlur = 6;
                ctx.fillText("æ— æ•ˆé”è‡‚è­¦å‘Š!", 20, 60);
                ctx.shadowBlur = 0;
            } else if (frame.supportState !== 'stable') {
                ctx.fillStyle = 'var(--warning)';
                ctx.font = `bold ${Math.max(16, c.width/25)}px Arial`;
                ctx.textAlign = 'left';
                ctx.shadowColor = 'rgba(0,0,0,0.9)';
                ctx.shadowBlur = 6;
                ctx.fillText("å¤±å»ä¸‰ç‚¹æ”¯æ’‘!", 20, 60);
                ctx.shadowBlur = 0;
            }
        }

        // ==================== ç»“æœæ˜¾ç¤º ====================
        
        function finish(results) {
            document.getElementById('status').innerText = "åˆ†æå®Œæˆ";
            document.getElementById('status').style.color = 'var(--success)';
            document.getElementById('replayBtn').style.display = 'block';
            
            const scoreCircle = document.getElementById('scoreCircle');
            const totalScoreEl = document.getElementById('totalScore');
            
            let curr = 0;
            const interval = setInterval(() => {
                if (curr >= results.total) {
                    clearInterval(interval);
                } else {
                    curr++;
                    totalScoreEl.textContent = curr;
                    scoreCircle.style.setProperty('--score', curr);
                }
            }, 15);

            const advice = generateAdvice(results);
            document.getElementById('aiAdvice').innerHTML = `<b>AI è®­ç»ƒå»ºè®®ï¼š</b><br>${advice.text}`;
            
            const badge = document.getElementById('gradeBadge');
            badge.innerText = `${advice.grade}çº§ - ${advice.grade === 'S' ? 'é¡¶å°–é«˜æ‰‹' : advice.grade === 'A' ? 'è¿›é˜¶é€‰æ‰‹' : advice.grade === 'B' ? 'æ½œåŠ›æ–°äºº' : 'éœ€è¦ç»ƒä¹ '}`;
            badge.style.borderColor = advice.gradeColor;
            badge.style.color = advice.gradeColor;
            badge.style.background = advice.gradeColor.replace(')', ', 0.2)').replace('rgb', 'rgba').replace('#', '');

            const m = results.metrics;
            document.getElementById('metrics').innerHTML = `
                <div class="metric">
                    <div class="metric-header">
                        <div class="metric-name"><div style="background:rgba(139,92,246,0.2);padding:4px;border-radius:6px;">ğŸ§—</div>åŠ¨ä½œç»“æ„è´¨é‡ (30%)</div>
                        <div class="metric-score">${Math.round(results.structure.total)}åˆ†</div>
                    </div>
                    <div class="metric-bar-bg"><div class="metric-bar-fill" style="width:0%; background:var(--accent);" data-w="${results.structure.total}%"></div></div>
                    <div class="sub-metric">ä¸‰ç‚¹æ”¯æ’‘: ${results.structure.threePoint}åˆ† (ç¨³å®š${m.stableFrames}/çŸ­æš‚å¤±è¡¡${m.briefUnstableFrames}/æŒç»­å¤±è¡¡${m.unstableFrames})</div>
                    <div class="sub-metric">è½¬æ¢åˆç†: ${results.structure.conversion}åˆ† (è¿è§„${m.conversionViolations}æ¬¡)</div>
                </div>
                
                <div class="metric">
                    <div class="metric-header">
                        <div class="metric-name"><div style="background:rgba(139,92,246,0.2);padding:4px;border-radius:6px;">âš–ï¸</div>èº«ä½“æ§åˆ¶èƒ½åŠ› (30%)</div>
                        <div class="metric-score">${Math.round(results.control.total)}åˆ†</div>
                    </div>
                    <div class="metric-bar-bg"><div class="metric-bar-fill" style="width:0%; background:var(--accent);" data-w="${results.control.total}%"></div></div>
                    <div class="sub-metric">é‡å¿ƒç¨³å®š: ${results.control.stability}åˆ† (æŠ–åŠ¨${m.instabilityFrames}å¸§)</div>
                    <div class="sub-metric">å¤±è¡¡æ¢å¤: ${results.control.recovery}åˆ† (å¹³å‡${m.recoveryTimes.length > 0 ? (m.recoveryTimes.reduce((a,b)=>a+b,0)/m.recoveryTimes.length).toFixed(2) : 0}s)</div>
                </div>
                
                <div class="metric">
                    <div class="metric-header">
                        <div class="metric-name"><div style="background:rgba(139,92,246,0.2);padding:4px;border-radius:6px;">ã€°ï¸</div>åŠ¨ä½œæ•ˆç‡ (25%)</div>
                        <div class="metric-score">${Math.round(results.efficiency.total)}åˆ†</div>
                    </div>
                    <div class="metric-bar-bg"><div class="metric-bar-fill" style="width:0%; background:var(--accent);" data-w="${results.efficiency.total}%"></div></div>
                    <div class="sub-metric">åŠ¨ä½œæµç•…: ${results.efficiency.flow}åˆ† (åœé¡¿${m.pauseCount}æ¬¡/${m.totalPauseDuration.toFixed(1)}s)</div>
                    <div class="sub-metric">é¢„æ‘†èƒ½åŠ›: ${results.efficiency.prep}åˆ† (${m.movementCount > 0 ? Math.round((1-m.noPrepCount/m.movementCount)*100) : 0}%æœ‰é¢„æ‘†)</div>
                </div>
                
                <div class="metric">
                    <div class="metric-header">
                        <div class="metric-name"><div style="background:rgba(139,92,246,0.2);padding:4px;border-radius:6px;">ğŸ”’</div>æŠ€æœ¯é£é™© (15%)</div>
                        <div class="metric-score">${Math.round(results.techniqueRisk.total)}åˆ†</div>
                    </div>
                    <div class="metric-bar-bg"><div class="metric-bar-fill" style="width:0%; background:var(--accent);" data-w="${results.techniqueRisk.total}%"></div></div>
                    <div class="sub-metric">é”è‡‚æ£€æµ‹: ${results.techniqueRisk.lockArm}åˆ† (ç´¯è®¡${m.lockDuration.total.toFixed(1)}s/${m.lockEvents.length}æ¬¡)</div>
                </div>
            `;

            setTimeout(() => {
                document.querySelectorAll('.metric-bar-fill').forEach(b => b.style.width = b.dataset.w);
            }, 300);

            document.getElementById('scoreCard').style.display = 'block';
            window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
        }

        // é¡µé¢åŠ è½½å®Œæˆåçš„åˆå§‹åŒ–
        window.onload = () => {
            log('é¡µé¢åŠ è½½å®Œæˆ');
            log(`UserAgent: ${navigator.userAgent.substring(0, 50)}...`);
        };
    </script>
</body>
</html>