<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ”€å²©åˆ†æä»ª iOS Pro - å†…è”æ’­æ”¾ç‰ˆ</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/pose.js"></script>
    <style>
        :root { 
            --accent: #8b5cf6; 
            --accent-light: #a78bfa;
            --success: #22c55e;
            --warning: #f59e0b;
            --danger: #ef4444;
        }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; 
            background: #000; color: #fff; margin: 0; padding: 15px; min-height: 100vh;
            -webkit-text-size-adjust: 100%;
        }
        .box { 
            background: #111; border: 1px solid #333; border-radius: 12px; padding: 15px; margin-bottom: 15px; text-align: center; 
        }
        .video-wrap { 
            position: relative; width: 100%; max-width: 480px; margin: 0 auto 15px; border-radius: 12px; 
            overflow: hidden; display: none; background: #000; 
            -webkit-overflow-scrolling: touch;
            -webkit-transform: translateZ(0);
        }
        video { 
            width: 100%; height: auto; display: block; object-fit: contain;
            -webkit-playsinline: true;
            playsinline: true;
            webkit-playsinline: true;
            x5-playsinline: true;
            x5-video-player-type: h5;
            x5-video-player-fullscreen: false;
            x5-video-orientation: portraint;
            pointer-events: none;
        }
        canvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            z-index: 10;
        }
        
        .video-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
            display: flex;
            align-items: center;
            padding: 0 15px;
            z-index: 20;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .video-wrap:hover .video-controls,
        .video-wrap:active .video-controls {
            opacity: 1;
        }
        .play-btn {
            width: 40px;
            height: 40px;
            background: rgba(255,255,255,0.2);
            border-radius: 50%;
            border: none;
            color: #fff;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
        .time-display {
            margin-left: 15px;
            font-size: 14px;
            color: #fff;
        }
        
        .status-indicator {
            position: absolute; top: 15px; left: 15px; padding: 5px 12px; border-radius: 20px;
            background: rgba(0,0,0,0.6); font-size: 12px; display: flex; align-items: center; gap: 6px;
            z-index: 20;
        }
        .dot { width: 8px; height: 8px; border-radius: 50%; background: var(--success); transition: 0.3s; }

        .btn { 
            background: var(--accent); color: #fff; border: none; padding: 15px 30px; border-radius: 10px; 
            font-weight: bold; width: 100%; font-size: 16px; margin: 10px 0; cursor: pointer; transition: all 0.3s ease;
            -webkit-tap-highlight-color: transparent;
        }
        .btn:active { transform: scale(0.98); opacity: 0.9; }

        #progress-container { 
            position: relative;
            height: 20px; 
            background: #222; 
            width: 100%; 
            margin: 10px 0; 
            border-radius: 10px; 
            display: none; 
            cursor: pointer;
            overflow: hidden;
            touch-action: none;
        }
        #progress-bar {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 4px;
            background: #333;
            transform: translateY(-50%);
            pointer-events: none;
        }
        #progress-fill { 
            height: 100%; 
            background: linear-gradient(90deg, var(--accent), var(--accent-light)); 
            width: 0%; 
            transition: width 0.1s linear;
            position: relative;
        }
        .progress-thumb {
            position: absolute;
            right: -8px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
            pointer-events: none;
        }
        .time-tooltip {
            position: absolute;
            top: -35px;
            background: rgba(0,0,0,0.9);
            color: #fff;
            padding: 5px 10px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            transform: translateX(-50%);
            white-space: nowrap;
        }
        #progress-container:hover .time-tooltip,
        #progress-container:active .time-tooltip {
            opacity: 1;
        }

        .score-card { 
            background: linear-gradient(145deg, #1a1a24, #111118); padding: 25px; border-radius: 20px; 
            display: none; border: 1px solid rgba(139, 92, 246, 0.2); box-shadow: 0 25px 50px rgba(0,0,0,0.5);
        }
        .score-header { text-align: center; margin-bottom: 25px; padding-bottom: 20px; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .score-circle {
            width: 140px; height: 140px; margin: 0 auto 15px; border-radius: 50%;
            background: conic-gradient(var(--accent) calc(var(--score) * 1%), #222 calc(var(--score) * 1%));
            display: flex; align-items: center; justify-content: center; position: relative;
        }
        .score-circle::before { content: ''; position: absolute; width: 110px; height: 110px; background: #1a1a24; border-radius: 50%; }
        .score-value { position: relative; font-size: 42px; font-weight: bold; color: var(--accent); z-index: 1; }
        
        .ai-advice {
            background: rgba(139, 92, 246, 0.1); border-left: 3px solid var(--accent);
            padding: 15px; border-radius: 0 12px 12px 0; margin-top: 20px; font-size: 14px; line-height: 1.6; text-align: left;
        }

        .metric { background: rgba(255,255,255,0.03); padding: 15px; border-radius: 12px; margin: 12px 0; }
        .metric-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .metric-name { font-size: 15px; color: #ccc; display: flex; align-items: center; gap: 8px; }
        .metric-score { font-size: 20px; font-weight: bold; color: #fff; }
        .metric-bar-bg { height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden; }
        .metric-bar-fill { height: 100%; border-radius: 3px; transition: width 1s ease-out; position: relative; overflow: hidden; }
        .metric-bar-fill::after {
            content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 2s infinite;
        }
        @keyframes shimmer { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } }
        .grade-badge {
            display: inline-block; padding: 6px 16px; border: 1px solid var(--accent);
            border-radius: 20px; font-size: 13px; color: var(--accent); font-weight: 600; margin-top: 10px;
        }
        .lock-warning { color: var(--danger); font-weight: bold; animation: blink 1s infinite; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        
        .debug-info {
            font-size: 12px; color: #666; margin-top: 10px; font-family: monospace;
        }
        
        .sub-metric {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
            padding-left: 10px;
            border-left: 2px solid rgba(139, 92, 246, 0.3);
        }
    </style>
<base target="_blank">
</head>
<body>

    <div id="status" class="box">è¯·ä¸Šä¼ æ”€å²©åŠ¨ä½œè§†é¢‘<br><span style="font-size:12px;color:#666">iOSç³»ç»Ÿæ‹–æ‹½è¿›åº¦æ¡è§‚çœ‹éª¨éª¼ç‚¹</span></div>

    <input type="file" id="videoInput" accept="video/*" style="display:none">
    <button class="btn" id="selectBtn" onclick="document.getElementById('videoInput').click()">ğŸ“ é€‰æ‹©è§†é¢‘</button>
    <button class="btn" id="startBtn" style="display:none; background:var(--success);" onclick="beginProcess()">ğŸš€ å¼€å§‹æ™ºèƒ½åˆ†æ</button>

    <div class="video-wrap" id="videoWrap">
        <div class="status-indicator">
            <div class="dot" id="statusDot"></div>
            <span id="statusText">AI ç›‘æ§ä¸­</span>
        </div>
        <video id="v" playsinline webkit-playsinline muted preload="auto"></video>
        <canvas id="c"></canvas>
        
        <div class="video-controls" id="videoControls">
            <button class="play-btn" id="playPauseBtn" onclick="togglePlay()">â–¶</button>
            <span class="time-display" id="timeDisplay">0:00 / 0:00</span>
        </div>
    </div>
    <div id="progress-container">
        <div id="progress-bar">
            <div id="progress-fill">
                <div class="progress-thumb"></div>
            </div>
        </div>
        <div class="time-tooltip" id="timeTooltip">00:00</div>
    </div>

    <button class="btn" id="replayBtn" style="display:none; background:#333; margin-top: 0;" onclick="resetAndPlay()">ğŸï¸ é‡æ–°æ’­æ”¾</button>

    <div class="score-card" id="scoreCard">
        <div class="score-header">
            <div class="score-circle" id="scoreCircle" style="--score: 0;">
                <div class="score-value" id="totalScore">0</div>
            </div>
            <div style="font-size: 14px; color: #888; letter-spacing: 2px;">ç»¼åˆè¡¨ç°å¾—åˆ†</div>
            <div class="grade-badge" id="gradeBadge">è®¡ç®—ä¸­...</div>
        </div>

        <div id="metrics"></div>
        <div class="debug-info" id="debugInfo"></div>

        <div class="ai-advice" id="aiAdvice">
            <b>AI è®­ç»ƒå»ºè®®ï¼š</b><br>
            æ­£åœ¨æ ¹æ®ä½ çš„åŠ¨ä½œç”Ÿæˆä¸ªæ€§åŒ–æ”¹è¿›æ–¹æ¡ˆ...
        </div>
    </div>

    <script>
        // ==================== å…¨å±€é…ç½® ====================
        const CONFIG = {
            // é˜ˆå€¼é…ç½®
            STABLE_VELOCITY_THRESHOLD: 0.02,      // è‚¢ä½“ç¨³å®šé€Ÿåº¦é˜ˆå€¼
            CENTER_VELOCITY_SMALL: 0.01,           // é‡å¿ƒåœé¡¿é€Ÿåº¦é˜ˆå€¼
            CENTER_VELOCITY_HIGH: 0.05,            // é‡å¿ƒé«˜é€Ÿé˜ˆå€¼
            ACCELERATION_HIGH: 0.1,                // é«˜åŠ é€Ÿåº¦é˜ˆå€¼ï¼ˆæŠ–åŠ¨ï¼‰
            INSTABILITY_TIME_THRESHOLD: 0.3,       // å¤±è¡¡æ—¶é—´é˜ˆå€¼ï¼ˆç§’ï¼‰
            PAUSE_TIME_THRESHOLD: 0.5,             // åœé¡¿æ—¶é—´é˜ˆå€¼ï¼ˆç§’ï¼‰
            LOCK_ARM_TIME_THRESHOLD: 1.0,          // é”è‡‚æ—¶é—´é˜ˆå€¼ï¼ˆç§’ï¼‰
            PRE_MOVEMENT_TIME: 0.3,                // é¢„æ‘†æå‰æ—¶é—´ï¼ˆç§’ï¼‰
            
            // è¯„åˆ†æƒé‡
            WEIGHTS: {
                STRUCTURE: 0.30,
                CONTROL: 0.30,
                EFFICIENCY: 0.25,
                TECHNIQUE_RISK: 0.15
            },
            
            // å­æ¨¡å—æƒé‡
            SUB_WEIGHTS: {
                THREE_POINT: 0.20,
                CONVERSION: 0.10,
                STABILITY: 0.15,
                RECOVERY: 0.15,
                FLOW: 0.15,
                PREP: 0.10,
                LOCK_ARM: 0.15
            }
        };

        // ==================== å…¨å±€å˜é‡ ====================
        const v = document.getElementById('v'), c = document.getElementById('c'), ctx = c.getContext('2d');
        const progressContainer = document.getElementById('progress-container');
        const progressFill = document.getElementById('progress-fill');
        const timeTooltip = document.getElementById('timeTooltip');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const timeDisplay = document.getElementById('timeDisplay');
        
        let pose, videoDuration = 0;
        let isAnalyzing = false;
        let isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        
        // æ•°æ®å­˜å‚¨
        let frameDataList = [];  // FrameDataæ•°ç»„
        let videoMetrics = null; // VideoMetricsèšåˆæ•°æ®
        
        // ä¸´æ—¶çŠ¶æ€è¿½è¸ª
        let lastFrameData = null;
        let lockArmState = { left: { startTime: null, isLocking: false }, right: { startTime: null, isLocking: false } };
        let pauseState = { startTime: null, isPausing: false };
        let instabilityState = { startTime: null, isUnstable: false };
        let supportViolationState = { startTime: null, isViolating: false };

        // ==================== æ•°æ®ç»“æ„å®šä¹‰ ====================
        
        // æ¯å¸§æ•°æ®ç»“æ„
        class FrameData {
            constructor(time, landmarks) {
                this.time = time;
                this.landmarks = landmarks ? JSON.parse(JSON.stringify(landmarks)) : null;
                
                // åŸºç¡€è¿åŠ¨å‚æ•°
                this.center = { x: 0, y: 0 };           // é‡å¿ƒåæ ‡
                this.velocity = 0;                       // é‡å¿ƒé€Ÿåº¦
                this.acceleration = 0;                   // é‡å¿ƒåŠ é€Ÿåº¦
                
                // è‚¢ä½“é€Ÿåº¦ [å·¦æ‰‹, å³æ‰‹, å·¦è„š, å³è„š]
                this.limbVelocity = [0, 0, 0, 0];
                
                // çŠ¶æ€æ ‡è®°
                this.supportState = 'stable';           // stable, brief_unstable, unstable
                this.pauseState = false;                // æ˜¯å¦åœé¡¿
                this.lockState = { left: false, right: false, isLocking: false };
                this.instabilityState = false;          // æ˜¯å¦æŠ–åŠ¨
                this.preMovementState = false;          // æ˜¯å¦æœ‰é¢„æ‘†
                
                // è§’åº¦æ•°æ®
                this.angles = {
                    leftElbow: 0, rightElbow: 0,
                    leftShoulder: 0, rightShoulder: 0
                };
                
                // è¾…åŠ©æ•°æ®
                this.supportPoints = 0;                 // ç¨³å®šæ”¯æ’‘ç‚¹æ•°
                this.movingLimbs = 0;                   // ç§»åŠ¨è‚¢ä½“æ•°
            }
        }
        
        // è§†é¢‘èšåˆæŒ‡æ ‡
        class VideoMetrics {
            constructor() {
                this.totalFrames = 0;
                this.totalDuration = 0;
                
                // Structureæ¨¡å—
                this.stableFrames = 0;
                this.briefUnstableFrames = 0;
                this.unstableFrames = 0;
                this.supportViolationFrames = 0;
                this.conversionViolations = 0;          // åŒæ‰‹åŒæ—¶ç§»åŠ¨æ¬¡æ•°
                
                // Controlæ¨¡å—
                this.instabilityFrames = 0;
                this.recoveryTimes = [];                // å¤±è¡¡æ¢å¤æ—¶é—´æ•°ç»„
                
                // Efficiencyæ¨¡å—
                this.pauseCount = 0;
                this.totalPauseDuration = 0;
                this.movementCount = 0;                 // æ€»æ¢ç‚¹æ¬¡æ•°
                this.noPrepCount = 0;                   // æ— é¢„æ‘†æ¬¡æ•°
                
                // Technique Riskæ¨¡å—
                this.lockDuration = { left: 0, right: 0, total: 0 };
                this.lockEvents = [];                   // é”è‡‚äº‹ä»¶è®°å½•
            }
        }

        // ==================== åŸºç¡€è¿åŠ¨å‚æ•°è®¡ç®—å±‚ ====================
        
        function computeLimbVelocity(current, previous, dt) {
            if (!previous || dt <= 0) return [0, 0, 0, 0];
            
            const limbs = [
                [15, 16, 27, 28], // å·¦æ‰‹ã€å³æ‰‹ã€å·¦è„šã€å³è„šçš„ç´¢å¼•
            ][0];
            
            const velocities = [];
            const limbIndices = [15, 16, 27, 28]; // å·¦æ‰‹è…•ã€å³æ‰‹è…•ã€å·¦è„šè¸ã€å³è„šè¸
            
            for (let idx of limbIndices) {
                const curr = current[idx];
                const prev = previous[idx];
                if (curr && prev && curr.visibility > 0.5 && prev.visibility > 0.5) {
                    const dx = curr.x - prev.x;
                    const dy = curr.y - prev.y;
                    const velocity = Math.sqrt(dx*dx + dy*dy) / dt;
                    velocities.push(velocity);
                } else {
                    velocities.push(0);
                }
            }
            
            return velocities;
        }
        
        function computeCenterVelocity(currentCenter, previousCenter, dt) {
            if (!previousCenter || dt <= 0) return 0;
            const dx = currentCenter.x - previousCenter.x;
            const dy = currentCenter.y - previousCenter.y;
            return Math.sqrt(dx*dx + dy*dy) / dt;
        }
        
        function computeAcceleration(currentVelocity, previousVelocity, dt) {
            if (!previousVelocity || dt <= 0) return 0;
            return Math.abs(currentVelocity - previousVelocity) / dt;
        }
        
        function getAngle(p1, p2, p3) {
            const rad = Math.atan2(p3.y - p2.y, p3.x - p2.x) - Math.atan2(p1.y - p2.y, p1.x - p2.x);
            let angle = Math.abs(rad * 180 / Math.PI);
            return angle > 180 ? 360 - angle : angle;
        }

        // ==================== è¡Œä¸ºè¯†åˆ«å±‚ ====================
        
        function detectThreePointSupport(frame, prevFrame) {
            // è®¡ç®—ç¨³å®šæ”¯æ’‘ç‚¹æ•°ï¼ˆè‚¢ä½“é€Ÿåº¦ < é˜ˆå€¼ï¼‰
            let stablePoints = 0;
            let movingLimbs = 0;
            
            for (let i = 0; i < 4; i++) {
                if (frame.limbVelocity[i] < CONFIG.STABLE_VELOCITY_THRESHOLD) {
                    stablePoints++;
                } else {
                    movingLimbs++;
                }
            }
            
            frame.supportPoints = stablePoints;
            frame.movingLimbs = movingLimbs;
            
            // æ£€æµ‹åŒæ‰‹åŒæ—¶ç§»åŠ¨ï¼ˆè¿è§„è½¬æ¢ï¼‰
            const handsMoving = (frame.limbVelocity[0] > CONFIG.STABLE_VELOCITY_THRESHOLD && 
                               frame.limbVelocity[1] > CONFIG.STABLE_VELOCITY_THRESHOLD);
            
            // çŠ¶æ€åˆ†ç±»
            if (stablePoints >= 3) {
                frame.supportState = 'stable';
            } else if (stablePoints < 3) {
                // çŸ­æš‚å¤±è¡¡ vs æŒç»­å¤±è¡¡ç”±æ—¶é—´èšåˆå±‚å¤„ç†
                frame.supportState = 'unstable';
            }
            
            return { stablePoints, handsMoving, isViolation: stablePoints < 3 };
        }
        
        function detectInstability(frame, prevFrame) {
            // åŸºäºåŠ é€Ÿåº¦æ£€æµ‹æŠ–åŠ¨
            const isHighAccel = frame.acceleration > CONFIG.ACCELERATION_HIGH;
            const isHighVel = frame.velocity > CONFIG.CENTER_VELOCITY_HIGH;
            
            // æŠ–åŠ¨å®šä¹‰ï¼šé«˜åŠ é€Ÿåº¦ä¸”éä¸»åŠ¨é«˜é€Ÿç§»åŠ¨
            frame.instabilityState = isHighAccel && !isHighVel;
            return frame.instabilityState;
        }
        
        function detectPause(frame, prevFrame) {
            // åœé¡¿æ£€æµ‹ï¼šé‡å¿ƒé€Ÿåº¦ < å°é˜ˆå€¼
            const isLowVel = frame.velocity < CONFIG.CENTER_VELOCITY_SMALL;
            return isLowVel; // æŒç»­æ—¶é—´ç”±æ—¶é—´èšåˆå±‚å¤„ç†
        }
        
        function detectPreMovement(currentFrame, frameHistory) {
            // é¢„æ‘†æ£€æµ‹ï¼šåœ¨æ‰‹ç§»åŠ¨å‰0.3ç§’ï¼Œé‡å¿ƒæ˜¯å¦æœç›®æ ‡æ–¹å‘ç§»åŠ¨
            if (!currentFrame || frameHistory.length < 3) return false;
            
            // æŸ¥æ‰¾å½“å‰ç§»åŠ¨çš„è‚¢ä½“
            const movingLimbs = [];
            for (let i = 0; i < 4; i++) {
                if (currentFrame.limbVelocity[i] > CONFIG.STABLE_VELOCITY_THRESHOLD) {
                    movingLimbs.push(i);
                }
            }
            
            if (movingLimbs.length === 0) return false;
            
            // æ£€æŸ¥0.3ç§’å‰çš„å¸§
            const preTime = currentFrame.time - CONFIG.PRE_MOVEMENT_TIME;
            const preFrame = frameHistory.find(f => Math.abs(f.time - preTime) < 0.1);
            
            if (!preFrame) return false;
            
            // ç®€å•åˆ¤æ–­ï¼šé‡å¿ƒæ˜¯å¦æœ‰æ˜æ˜¾ç§»åŠ¨è¶‹åŠ¿
            const dx = currentFrame.center.x - preFrame.center.x;
            const dy = currentFrame.center.y - preFrame.center.y;
            const preMovement = Math.sqrt(dx*dx + dy*dy) > 0.01;
            
            currentFrame.preMovementState = preMovement;
            return preMovement;
        }
        
        function detectLockArm(frame) {
            if (!frame.landmarks) return { left: false, right: false };
            
            const lm = frame.landmarks;
            
            // è®¡ç®—è§’åº¦
            frame.angles.leftElbow = getAngle(lm[11], lm[13], lm[15]);
            frame.angles.rightElbow = getAngle(lm[12], lm[14], lm[16]);
            frame.angles.leftShoulder = getAngle(lm[23], lm[11], lm[13]);
            frame.angles.rightShoulder = getAngle(lm[24], lm[12], lm[14]);
            
            // é”è‡‚åˆ¤å®šæ¡ä»¶ï¼šè‚˜è§’<90Â° ä¸” è‚©è§’<120Â°
            const isLeftLocking = frame.angles.leftElbow < 90 && frame.angles.leftShoulder < 120;
            const isRightLocking = frame.angles.rightElbow < 90 && frame.angles.rightShoulder < 120;
            
            // æ£€æŸ¥é‡å¿ƒYæ˜¯å¦æ˜æ˜¾ä¸Šå‡ï¼ˆæ’é™¤æ­£å¸¸æ”€çˆ¬ï¼‰
            let isRising = false;
            if (lastFrameData) {
                const dy = lastFrameData.center.y - frame.center.y; // Yè½´å‘ä¸‹ä¸ºæ­£
                isRising = dy > 0.02; // é‡å¿ƒä¸Šå‡è¶…è¿‡é˜ˆå€¼
            }
            
            // æœ€ç»ˆé”è‡‚åˆ¤å®šï¼ˆæŒç»­æ—¶é—´åœ¨æ—¶é—´èšåˆå±‚å¤„ç†ï¼‰
            frame.lockState.left = isLeftLocking && !isRising;
            frame.lockState.right = isRightLocking && !isRising;
            frame.lockState.isLocking = frame.lockState.left || frame.lockState.right;
            
            return frame.lockState;
        }

        // ==================== æ—¶é—´èšåˆå±‚ ====================
        
        function aggregateTimeMetrics(frames, duration) {
            const metrics = new VideoMetrics();
            metrics.totalFrames = frames.length;
            metrics.totalDuration = duration;
            
            // ä¸´æ—¶çŠ¶æ€è¿½è¸ª
            let unstableStartTime = null;
            let pauseStartTime = null;
            let lockStartTime = { left: null, right: null };
            let lastHandsMovingTime = null;
            let recoveryStartTime = null;
            
            for (let i = 0; i < frames.length; i++) {
                const frame = frames[i];
                const prevFrame = i > 0 ? frames[i-1] : null;
                const nextFrame = i < frames.length - 1 ? frames[i+1] : null;
                const dt = nextFrame ? (nextFrame.time - frame.time) : 0.1;
                
                // --- ä¸‰ç‚¹æ”¯æ’‘èšåˆ ---
                if (frame.supportState === 'stable') {
                    metrics.stableFrames++;
                    unstableStartTime = null;
                } else {
                    if (!unstableStartTime) unstableStartTime = frame.time;
                    const unstableDuration = frame.time - unstableStartTime;
                    
                    if (unstableDuration < CONFIG.INSTABILITY_TIME_THRESHOLD) {
                        metrics.briefUnstableFrames++;
                    } else {
                        metrics.unstableFrames++;
                    }
                }
                
                // æ”¯æ’‘è½¬æ¢è¿è§„ï¼ˆåŒæ‰‹åŒæ—¶ç§»åŠ¨ï¼‰
                if (frame.movingLimbs >= 2) {
                    if (!lastHandsMovingTime || (frame.time - lastHandsMovingTime) > 0.5) {
                        metrics.conversionViolations++;
                        metrics.supportViolationFrames++;
                        lastHandsMovingTime = frame.time;
                    }
                }
                
                // --- é‡å¿ƒç¨³å®šåº¦èšåˆ ---
                if (frame.instabilityState) {
                    metrics.instabilityFrames++;
                    if (!recoveryStartTime) recoveryStartTime = frame.time;
                } else {
                    if (recoveryStartTime) {
                        const recoveryTime = frame.time - recoveryStartTime;
                        metrics.recoveryTimes.push(recoveryTime);
                        recoveryStartTime = null;
                    }
                }
                
                // --- åœé¡¿æ£€æµ‹èšåˆ ---
                const isLowVel = frame.velocity < CONFIG.CENTER_VELOCITY_SMALL;
                if (isLowVel) {
                    if (!pauseStartTime) pauseStartTime = frame.time;
                    const pauseDuration = frame.time - pauseStartTime;
                    if (pauseDuration >= CONFIG.PAUSE_TIME_THRESHOLD && !frame.pauseState) {
                        frame.pauseState = true;
                        metrics.pauseCount++;
                        metrics.totalPauseDuration += pauseDuration;
                    }
                } else {
                    pauseStartTime = null;
                }
                
                // --- é”è‡‚æ£€æµ‹èšåˆ ---
                ['left', 'right'].forEach(side => {
                    if (frame.lockState[side]) {
                        if (!lockStartTime[side]) lockStartTime[side] = frame.time;
                        const lockDuration = frame.time - lockStartTime[side];
                        
                        if (lockDuration >= CONFIG.LOCK_ARM_TIME_THRESHOLD) {
                            metrics.lockDuration[side] += dt;
                            metrics.lockDuration.total += dt;
                            if (!frame.lockState.isLocking) frame.lockState.isLocking = true;
                        }
                    } else {
                        if (lockStartTime[side]) {
                            const duration = frame.time - lockStartTime[side];
                            if (duration >= CONFIG.LOCK_ARM_TIME_THRESHOLD) {
                                metrics.lockEvents.push({ side, duration, time: lockStartTime[side] });
                            }
                            lockStartTime[side] = null;
                        }
                    }
                });
                
                // --- é¢„æ‘†æ£€æµ‹ ---
                if (i > 5) {
                    const history = frames.slice(Math.max(0, i-10), i);
                    const hasPrep = detectPreMovement(frame, history);
                    if (frame.movingLimbs > 0) {
                        metrics.movementCount++;
                        if (!hasPrep) metrics.noPrepCount++;
                    }
                }
            }
            
            return metrics;
        }

        // ==================== è¯„åˆ†è®¡ç®—å±‚ ====================
        
        function calculateScores(metrics) {
            const scores = {};
            
            // 1. STRUCTURE (30%)
            // 1.1 ä¸‰ç‚¹æ”¯æ’‘ç¨³å®šåº¦ (20%)
            const totalFrames = metrics.totalFrames || 1;
            const threePointScore = ((metrics.stableFrames + 0.5 * metrics.briefUnstableFrames) / totalFrames) * 100;
            
            // 1.2 æ”¯æ’‘è½¬æ¢åˆç†æ€§ (10%)
            const violationRatio = metrics.supportViolationFrames / totalFrames;
            const conversionScore = 100 * (1 - violationRatio);
            
            scores.structure = {
                total: threePointScore * (CONFIG.SUB_WEIGHTS.THREE_POINT / 0.30) + 
                       conversionScore * (CONFIG.SUB_WEIGHTS.CONVERSION / 0.30),
                threePoint: Math.round(threePointScore),
                conversion: Math.round(conversionScore)
            };
            
            // 2. CONTROL (30%)
            // 2.1 é‡å¿ƒç¨³å®šåº¦ (15%)
            const instabilityRatio = metrics.instabilityFrames / totalFrames;
            const stabilityScore = 100 * (1 - instabilityRatio);
            
            // 2.2 å¤±è¡¡æ¢å¤èƒ½åŠ› (15%)
            let recoveryScore = 100;
            if (metrics.recoveryTimes.length > 0) {
                const avgRecovery = metrics.recoveryTimes.reduce((a,b) => a+b, 0) / metrics.recoveryTimes.length;
                recoveryScore = Math.max(0, 100 - avgRecovery * 50); // k=50çš„æƒ©ç½šç³»æ•°
            }
            
            scores.control = {
                total: stabilityScore * (CONFIG.SUB_WEIGHTS.STABILITY / 0.30) + 
                       recoveryScore * (CONFIG.SUB_WEIGHTS.RECOVERY / 0.30),
                stability: Math.round(stabilityScore),
                recovery: Math.round(recoveryScore)
            };
            
            // 3. EFFICIENCY (25%)
            // 3.1 åŠ¨ä½œæµç•…åº¦ (15%)
            const flowScore = Math.max(0, Math.min(100, 100 - 15 * metrics.pauseCount));
            
            // 3.2 é‡å¿ƒé¢„æ‘†èƒ½åŠ› (10%)
            let prepScore = 100;
            if (metrics.movementCount > 0) {
                const noPrepRatio = metrics.noPrepCount / metrics.movementCount;
                prepScore = 100 * (1 - noPrepRatio);
            }
            
            scores.efficiency = {
                total: flowScore * (CONFIG.SUB_WEIGHTS.FLOW / 0.25) + 
                       prepScore * (CONFIG.SUB_WEIGHTS.PREP / 0.25),
                flow: Math.round(flowScore),
                prep: Math.round(prepScore)
            };
            
            // 4. TECHNIQUE RISK (15%)
            // 4.1 é”è‡‚æ£€æµ‹ (15%) - ä½¿ç”¨å¹³æ–¹æƒ©ç½š
            const lockRatio = metrics.lockDuration.total / (metrics.totalDuration || 1);
            const lockScore = 100 * (1 - Math.pow(lockRatio, 2));
            
            scores.techniqueRisk = {
                total: lockScore,
                lockArm: Math.round(lockScore)
            };
            
            // è®¡ç®—æ€»åˆ†
            const totalScore = 
                scores.structure.total * CONFIG.WEIGHTS.STRUCTURE +
                scores.control.total * CONFIG.WEIGHTS.CONTROL +
                scores.efficiency.total * CONFIG.WEIGHTS.EFFICIENCY +
                scores.techniqueRisk.total * CONFIG.WEIGHTS.TECHNIQUE_RISK;
            
            return {
                total: Math.round(totalScore),
                structure: scores.structure,
                control: scores.control,
                efficiency: scores.efficiency,
                techniqueRisk: scores.techniqueRisk,
                metrics: metrics
            };
        }

        // ==================== å»ºè®®ç”Ÿæˆå±‚ ====================
        
        function generateAdvice(results) {
            const s = results.structure;
            const ctrl = results.control;
            const eff = results.efficiency;
            const tech = results.techniqueRisk;
            const total = results.total;
            const m = results.metrics;
            
            let advice = [];
            let grade = '';
            let gradeColor = '';
            
            // ç­‰çº§åˆ¤å®š
            if (total >= 90) {
                grade = 'S';
                gradeColor = 'var(--success)';
                advice.push("ä½ çš„åŠ¨ä½œéå¸¸è€ç»ƒï¼ä¸‰ç‚¹ä¸åŠ¨åŸåˆ™è´¯å½»å¾—å¾ˆå½»åº•ï¼Œä¸”å¾ˆå°‘å‡ºç°é”è‡‚ã€‚");
            } else if (total >= 80) {
                grade = 'A';
                gradeColor = 'var(--accent)';
                advice.push("è¡¨ç°ä¸é”™ï¼Œæ•´ä½“åŠ¨ä½œæµç•…ï¼Œä½†åœ¨æŸäº›ç»†èŠ‚ä¸Šè¿˜æœ‰æå‡ç©ºé—´ã€‚");
            } else if (total >= 65) {
                grade = 'B';
                gradeColor = 'var(--warning)';
                advice.push("åŸºç¡€æ¯”è¾ƒæ‰å®ï¼Œä½†éœ€è¦é’ˆå¯¹æ€§æ”¹è¿›ä¸€äº›æŠ€æœ¯ç»†èŠ‚ã€‚");
            } else {
                grade = 'C';
                gradeColor = 'var(--danger)';
                advice.push("æ£€æµ‹åˆ°è¾ƒå¤šæŠ€æœ¯é—®é¢˜ï¼Œå»ºè®®é‡ç‚¹ç»ƒä¹ åŸºç¡€åŠ¨ä½œæ¨¡å¼ã€‚");
            }
            
            // å…·ä½“é—®é¢˜åˆ†æ
            const weaknesses = [];
            
            if (s.threePoint < 70) {
                weaknesses.push(`ä¸‰ç‚¹æ”¯æ’‘ç¨³å®šåº¦ä¸è¶³ï¼ˆ${s.threePoint}åˆ†ï¼‰ï¼Œæœ‰${m.unstableFrames}å¸§å¤±å»ç¨³å®šæ”¯æ’‘`);
                advice.push("å»ºè®®ï¼šå§‹ç»ˆä¿æŒè‡³å°‘3ä¸ªè‚¢ä½“ç¨³å®šæ¥è§¦å²©å£ï¼Œç§»åŠ¨å•è‚¢æ—¶ç¡®ä¿å…¶ä»–3ç‚¹ç‰¢å›ºã€‚");
            }
            
            if (s.conversion < 80) {
                weaknesses.push(`æ”¯æ’‘è½¬æ¢è¿è§„${m.conversionViolations}æ¬¡`);
                advice.push("å»ºè®®ï¼šé¿å…åŒæ‰‹åŒæ—¶ç¦»å¼€å²©ç‚¹ï¼Œé‡‡ç”¨'ä¸‰ç‚¹ä¸åŠ¨ä¸€ç‚¹åŠ¨'åŸåˆ™è¿›è¡Œæ¢ç‚¹ã€‚");
            }
            
            if (ctrl.stability < 70) {
                weaknesses.push(`é‡å¿ƒæ§åˆ¶ä¸ç¨³ï¼ˆ${ctrl.stability}åˆ†ï¼‰ï¼Œæ£€æµ‹åˆ°${m.instabilityFrames}å¸§æ— æ§åˆ¶æ™ƒåŠ¨`);
                advice.push("å»ºè®®ï¼šé€šè¿‡è…¿éƒ¨å‘åŠ›è€Œéæ‰‹è‡‚æ‹‰æ‹½æ¥æ§åˆ¶é‡å¿ƒç§»åŠ¨ï¼Œä¿æŒæ ¸å¿ƒæ”¶ç´§ã€‚");
            }
            
            if (ctrl.recovery < 70 && m.recoveryTimes.length > 0) {
                const avgRec = (m.recoveryTimes.reduce((a,b)=>a+b,0)/m.recoveryTimes.length).toFixed(2);
                weaknesses.push(`å¤±è¡¡æ¢å¤è¾ƒæ…¢ï¼Œå¹³å‡æ¢å¤æ—¶é—´${avgRec}ç§’`);
                advice.push("å»ºè®®ï¼šæå‰é¢„åˆ¤é‡å¿ƒåç§»ï¼Œåˆ©ç”¨åä½œç”¨åŠ›å¿«é€Ÿè°ƒæ•´å§¿æ€ã€‚");
            }
            
            if (eff.flow < 70) {
                weaknesses.push(`åŠ¨ä½œæµç•…åº¦ä¸è¶³ï¼ˆ${eff.flow}åˆ†ï¼‰ï¼Œæ£€æµ‹åˆ°${m.pauseCount}æ¬¡æ˜æ˜¾åœé¡¿`);
                advice.push("å»ºè®®ï¼šå‡å°‘ä¸å¿…è¦çš„åœé¡¿ï¼Œæå‰è§„åˆ’å¥½è·¯çº¿ï¼Œä¿æŒåŠ¨ä½œè¿è´¯æ€§ã€‚");
            }
            
            if (eff.prep < 70 && m.movementCount > 0) {
                const prepRate = ((1 - m.noPrepCount/m.movementCount) * 100).toFixed(0);
                weaknesses.push(`é‡å¿ƒé¢„æ‘†æ„è¯†ä¸è¶³ï¼ˆ${prepRate}%çš„æ¢ç‚¹æœ‰é¢„æ‘†ï¼‰`);
                advice.push("å»ºè®®ï¼šåœ¨æ‰‹éƒ¨ç§»åŠ¨å‰0.3ç§’ï¼Œæå‰å°†é‡å¿ƒæœç›®æ ‡æ–¹å‘åç§»ï¼Œåˆ©ç”¨åŠ¨é‡è¾…åŠ©ç§»åŠ¨ã€‚");
            }
            
            if (tech.lockArm < 70) {
                const lockSec = m.lockDuration.total.toFixed(1);
                weaknesses.push(`é”è‡‚é—®é¢˜ä¸¥é‡ï¼ˆ${tech.lockArm}åˆ†ï¼‰ï¼Œç´¯è®¡é”è‡‚${lockSec}ç§’`);
                advice.push(`å»ºè®®ï¼šæ‰‹è‡‚å°½é‡ä¿æŒè‡ªç„¶ä¼¸ç›´æŒ‚ç‚¹ï¼ˆè‚˜è§’>90Â°ï¼‰ï¼Œé€šè¿‡è…¿éƒ¨æ¨ªå‘ç§»åŠ¨æˆ–å‘åŠ›æ¥å¯»æ‰¾æ›´é«˜ç‚¹ï¼Œè€ŒéåŸåœ°å¼¯æ›²æ‰‹è‡‚åƒµæŒã€‚æ£€æµ‹åˆ°${m.lockEvents.length}æ¬¡é”è‡‚äº‹ä»¶ã€‚`);
            }
            
            if (weaknesses.length === 0) {
                advice.push("å„é¡¹æŠ€æœ¯æŒ‡æ ‡è¡¨ç°å‡è¡¡ï¼Œå»ºè®®ä¿æŒå½“å‰è®­ç»ƒèŠ‚å¥ï¼Œå°è¯•æé«˜åŠ¨ä½œéš¾åº¦ã€‚");
            }
            
            return {
                grade,
                gradeColor,
                text: advice.join('<br><br>'),
                weaknesses
            };
        }

        // ==================== UIå’Œåˆå§‹åŒ–ï¼ˆä¿æŒåŸæœ‰é€»è¾‘ï¼‰====================
        
        function setupIOSVideo() {
            if (isIOS) {
                v.setAttribute('playsinline', 'true');
                v.setAttribute('webkit-playsinline', 'true');
                v.setAttribute('x5-playsinline', 'true');
                v.style.objectFit = 'contain';
                v.removeAttribute('controls');
            }
        }

        function togglePlay() {
            if (v.paused) {
                v.play().then(() => {
                    playPauseBtn.innerText = 'â¸';
                }).catch(e => {
                    v.muted = true;
                    v.play();
                    playPauseBtn.innerText = 'â¸';
                });
            } else {
                v.pause();
                playPauseBtn.innerText = 'â–¶';
            }
        }

        function resetAndPlay() {
            v.currentTime = 0;
            togglePlay();
        }

        function updateTimeDisplay() {
            const current = formatTime(v.currentTime);
            const total = formatTime(videoDuration);
            timeDisplay.innerText = `${current} / ${total}`;
        }

        function formatTime(seconds) {
            if (!seconds || isNaN(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        v.addEventListener('timeupdate', () => {
            updateTimeDisplay();
            if (!isAnalyzing) {
                const frame = frameDataList.find(f => Math.abs(f.time - v.currentTime) < 0.25);
                if (frame) {
                    draw(frame);
                    updateStatusIndicator(frame);
                    const percent = (v.currentTime / videoDuration) * 100;
                    progressFill.style.width = percent + '%';
                }
            }
        });

        v.addEventListener('ended', () => {
            playPauseBtn.innerText = 'â–¶';
        });

        // ==================== MediaPipeåˆå§‹åŒ– ====================
        
        pose = new Pose({ 
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/${file}` 
        });
        
        pose.setOptions({ 
            modelComplexity: isIOS ? 0 : 1,
            smoothLandmarks: true, 
            minDetectionConfidence: 0.3,
            minTrackingConfidence: 0.3
        });
        
        pose.onResults(res => {
            if (!res.poseLandmarks) return;
            
            const lm = res.poseLandmarks;
            const currentTime = v.currentTime;
            
            // åˆ›å»ºå¸§æ•°æ®å¯¹è±¡
            const frame = new FrameData(currentTime, lm);
            
            // è®¡ç®—é‡å¿ƒï¼ˆé«‹éƒ¨ä¸­å¿ƒï¼‰
            if (lm[23] && lm[24]) {
                frame.center.x = (lm[23].x + lm[24].x) / 2;
                frame.center.y = (lm[23].y + lm[24].y) / 2;
            }
            
            // è®¡ç®—æ—¶é—´å·®
            let dt = 0.1;
            if (lastFrameData) {
                dt = currentTime - lastFrameData.time;
                if (dt <= 0) dt = 0.1;
            }
            
            // åŸºç¡€è¿åŠ¨å‚æ•°è®¡ç®—
            frame.limbVelocity = computeLimbVelocity(lm, lastFrameData ? lastFrameData.landmarks : null, dt);
            frame.velocity = computeCenterVelocity(frame.center, lastFrameData ? lastFrameData.center : null, dt);
            frame.acceleration = computeAcceleration(frame.velocity, lastFrameData ? lastFrameData.velocity : null, dt);
            
            // è¡Œä¸ºè¯†åˆ«
            detectThreePointSupport(frame, lastFrameData);
            detectInstability(frame, lastFrameData);
            detectLockArm(frame);
            
            // å­˜å‚¨å¸§æ•°æ®
            frameDataList.push(frame);
            lastFrameData = frame;
        });

        document.getElementById('videoInput').onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            setupIOSVideo();
            
            const url = URL.createObjectURL(file);
            v.src = url;
            v.load();
            
            document.getElementById('selectBtn').style.display = 'none';
            document.getElementById('startBtn').style.display = 'block';
            document.getElementById('status').innerHTML = "è§†é¢‘å·²å°±ç»ª<br><span style='font-size:12px;color:#666'>ç‚¹å‡»å¼€å§‹åˆ†æ</span>";
        };

        async function beginProcess() {
            document.getElementById('startBtn').style.display = 'none';
            document.getElementById('videoWrap').style.display = 'block';
            progressContainer.style.display = 'block';
            isAnalyzing = true;
            
            // é‡ç½®æ•°æ®
            frameDataList = [];
            lastFrameData = null;
            videoMetrics = null;
            
            v.muted = true;
            v.pause();
            
            if (v.readyState < 2) {
                await new Promise(resolve => {
                    v.onloadeddata = resolve;
                    setTimeout(resolve, 1000);
                });
            }
            
            videoDuration = v.duration;
            updateTimeDisplay();
            
            if (!videoDuration || isNaN(videoDuration)) {
                alert('æ— æ³•è¯»å–è§†é¢‘æ—¶é•¿ï¼Œè¯·å°è¯•å…¶ä»–è§†é¢‘');
                return;
            }
            
            const step = isIOS ? 0.3 : 0.2;
            c.width = v.videoWidth || 640;
            c.height = v.videoHeight || 480;

            let processedFrames = 0;
            
            for (let t = 0; t < videoDuration; t += step) {
                v.currentTime = t;
                
                await new Promise(resolve => {
                    const checkSeek = () => {
                        if (Math.abs(v.currentTime - t) < 0.1) {
                            resolve();
                        } else {
                            setTimeout(checkSeek, 50);
                        }
                    };
                    
                    const timeout = setTimeout(() => {
                        resolve();
                    }, 1000);
                    
                    v.onseeked = () => {
                        clearTimeout(timeout);
                        checkSeek();
                    };
                });
                
                try {
                    await pose.send({ image: v });
                    processedFrames++;
                } catch(e) {
                    console.error('å¤„ç†å¸§å¤±è´¥:', e);
                }
                
                const prog = Math.min(100, Math.round((t/videoDuration)*100));
                progressFill.style.width = prog + '%';
                document.getElementById('status').innerText = `åˆ†æä¸­ (${prog}%) - å¸§:${processedFrames}`;
            }
            
            isAnalyzing = false;
            
            document.getElementById('debugInfo').innerText = 
                `æ€»å¸§æ•°: ${frameDataList.length}, å¤„ç†å¸§: ${processedFrames}, è§†é¢‘æ—¶é•¿: ${videoDuration.toFixed(1)}s`;
            
            if (frameDataList.length === 0) {
                alert('æœªæ£€æµ‹åˆ°å§¿æ€ï¼Œè¯·ç¡®ä¿è§†é¢‘ä¸­æœ‰äººç‰©å…¨èº«å‡ºé•œ');
                return;
            }
            
            // æ‰§è¡Œæ—¶é—´èšåˆå’Œè¯„åˆ†è®¡ç®—
            videoMetrics = aggregateTimeMetrics(frameDataList, videoDuration);
            const results = calculateScores(videoMetrics);
            finish(results);
        }

        function handleProgressClick(e) {
            if (!videoDuration || frameDataList.length === 0) return;
            
            const rect = progressContainer.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const x = Math.max(0, Math.min(clientX - rect.left, rect.width));
            const percent = x / rect.width;
            const time = percent * videoDuration;
            
            v.currentTime = time;
            
            const mins = Math.floor(time / 60);
            const secs = Math.floor(time % 60);
            timeTooltip.textContent = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            timeTooltip.style.left = `${x}px`;
            
            const frame = frameDataList.reduce((prev, curr) => 
                Math.abs(curr.time - time) < Math.abs(prev.time - time) ? curr : prev
            );
            
            if (frame) {
                draw(frame);
                updateStatusIndicator(frame);
            }
        }

        progressContainer.addEventListener('click', handleProgressClick);
        progressContainer.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleProgressClick(e);
            progressContainer.addEventListener('touchmove', handleProgressClick);
        });
        progressContainer.addEventListener('touchend', () => {
            progressContainer.removeEventListener('touchmove', handleProgressClick);
        });

        function updateStatusIndicator(frame) {
            const isViolation = frame.supportState !== 'stable';
            const isLocked = frame.lockState.isLocking;
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            
            if (isViolation) {
                statusDot.style.background = 'var(--danger)';
                statusText.innerText = 'éä¸‰ç‚¹ä¸åŠ¨!';
            } else if (isLocked) {
                statusDot.style.background = 'var(--danger)';
                statusText.innerText = 'âš ï¸ æ— æ•ˆé”è‡‚';
            } else if (frame.instabilityState) {
                statusDot.style.background = 'var(--warning)';
                statusText.innerText = 'é‡å¿ƒä¸ç¨³';
            } else {
                statusDot.style.background = 'var(--success)';
                statusText.innerText = 'å§¿æ€é«˜æ•ˆ';
            }
        }

        function draw(frame) {
            ctx.clearRect(0, 0, c.width, c.height);
            
            if (!frame.landmarks) return;
            
            const lm = frame.landmarks;
            
            // æ ¹æ®çŠ¶æ€è®¾ç½®é¢œè‰²
            let strokeColor = '#8b5cf6'; // é»˜è®¤ç´«è‰²
            if (frame.lockState.isLocking) strokeColor = 'var(--danger)';
            else if (frame.supportState !== 'stable') strokeColor = 'var(--warning)';
            else if (frame.instabilityState) strokeColor = '#f59e0b';
            
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = Math.max(3, c.width/120); 
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            const conn = [
                [11,13],[13,15],[12,14],[14,16],
                [11,12],[11,23],[12,24],[23,24],
                [23,25],[24,26],[25,27],[26,28]
            ];
            
            conn.forEach(([s, e]) => {
                const p1 = lm[s], p2 = lm[e];
                if (p1 && p2 && p1.visibility > 0.5 && p2.visibility > 0.5) {
                    ctx.beginPath(); 
                    ctx.moveTo(p1.x*c.width, p1.y*c.height); 
                    ctx.lineTo(p2.x*c.width, p2.y*c.height); 
                    ctx.stroke();
                }
            });

            const keyPoints = [11, 12, 13, 14, 15, 16, 23, 24, 25, 26, 27, 28];
            keyPoints.forEach(idx => {
                const p = lm[idx];
                if (p && p.visibility > 0.5) {
                    ctx.beginPath();
                    ctx.arc(p.x*c.width, p.y*c.height, Math.max(4, c.width/80), 0, 2*Math.PI);
                    ctx.fillStyle = '#fff';
                    ctx.fill();
                }
            });

            // ç»˜åˆ¶é‡å¿ƒ
            if (frame.center) {
                const cx = frame.center.x * c.width;
                const cy = frame.center.y * c.height;
                
                ctx.beginPath();
                ctx.arc(cx, cy, Math.max(10, c.width/40), 0, 2*Math.PI);
                ctx.fillStyle = 'rgba(6, 182, 212, 0.3)';
                ctx.fill();
                ctx.strokeStyle = '#06b6d4';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(cx, cy, Math.max(5, c.width/80), 0, 2*Math.PI);
                ctx.fillStyle = '#06b6d4';
                ctx.fill();
                
                const crossSize = Math.max(15, c.width/30);
                ctx.beginPath();
                ctx.moveTo(cx - crossSize, cy);
                ctx.lineTo(cx + crossSize, cy);
                ctx.moveTo(cx, cy - crossSize);
                ctx.lineTo(cx, cy + crossSize);
                ctx.strokeStyle = '#06b6d4';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // ç»˜åˆ¶è§’åº¦ä¿¡æ¯
            if (frame.angles) {
                ctx.font = `bold ${Math.max(12, c.width/40)}px Arial`;
                ctx.textAlign = 'center';
                ctx.shadowColor = 'rgba(0,0,0,0.9)';
                ctx.shadowBlur = 4;
                
                const leftElbow = lm[13];
                if (leftElbow && leftElbow.visibility > 0.5) {
                    const isWarning = frame.lockState.left;
                    ctx.fillStyle = isWarning ? 'var(--danger)' : '#fff';
                    ctx.fillText(`${Math.round(frame.angles.leftElbow)}Â°`, leftElbow.x*c.width, leftElbow.y*c.height - 35);
                }
                
                const rightElbow = lm[14];
                if (rightElbow && rightElbow.visibility > 0.5) {
                    const isWarning = frame.lockState.right;
                    ctx.fillStyle = isWarning ? 'var(--danger)' : '#fff';
                    ctx.fillText(`${Math.round(frame.angles.rightElbow)}Â°`, rightElbow.x*c.width, rightElbow.y*c.height - 35);
                }
                
                ctx.shadowBlur = 0;
            }

            // ç»˜åˆ¶çŠ¶æ€è­¦å‘Š
            if (frame.lockState.isLocking) {
                ctx.fillStyle = 'var(--danger)';
                ctx.font = `bold ${Math.max(20, c.width/20)}px Arial`;
                ctx.textAlign = 'left';
                ctx.shadowColor = 'rgba(0,0,0,0.9)';
                ctx.shadowBlur = 6;
                ctx.fillText("æ— æ•ˆé”è‡‚è­¦å‘Š!", 20, 60);
                ctx.shadowBlur = 0;
            } else if (frame.supportState !== 'stable') {
                ctx.fillStyle = 'var(--warning)';
                ctx.font = `bold ${Math.max(16, c.width/25)}px Arial`;
                ctx.textAlign = 'left';
                ctx.shadowColor = 'rgba(0,0,0,0.9)';
                ctx.shadowBlur = 6;
                ctx.fillText("å¤±å»ä¸‰ç‚¹æ”¯æ’‘!", 20, 60);
                ctx.shadowBlur = 0;
            }
        }

        function finish(results) {
            document.getElementById('status').innerText = "åˆ†æå®Œæˆ";
            document.getElementById('status').style.color = 'var(--success)';
            document.getElementById('replayBtn').style.display = 'block';
            
            const scoreCircle = document.getElementById('scoreCircle');
            const totalScoreEl = document.getElementById('totalScore');
            
            // åŠ¨ç”»æ˜¾ç¤ºæ€»åˆ†
            let curr = 0;
            const interval = setInterval(() => {
                if (curr >= results.total) {
                    clearInterval(interval);
                } else {
                    curr++;
                    totalScoreEl.textContent = curr;
                    scoreCircle.style.setProperty('--score', curr);
                }
            }, 15);

            // ç”Ÿæˆå»ºè®®
            const advice = generateAdvice(results);
            document.getElementById('aiAdvice').innerHTML = `<b>AI è®­ç»ƒå»ºè®®ï¼š</b><br>${advice.text}`;
            
            const badge = document.getElementById('gradeBadge');
            badge.innerText = `${advice.grade}çº§ - ${advice.grade === 'S' ? 'é¡¶å°–é«˜æ‰‹' : advice.grade === 'A' ? 'è¿›é˜¶é€‰æ‰‹' : advice.grade === 'B' ? 'æ½œåŠ›æ–°äºº' : 'éœ€è¦ç»ƒä¹ '}`;
            badge.style.borderColor = advice.gradeColor;
            badge.style.color = advice.gradeColor;
            badge.style.background = advice.gradeColor.replace(')', ', 0.2)').replace('rgb', 'rgba').replace('#', '');

            // æ¸²æŸ“è¯¦ç»†æŒ‡æ ‡
            const m = results.metrics;
            document.getElementById('metrics').innerHTML = `
                <div class="metric">
                    <div class="metric-header">
                        <div class="metric-name"><div style="background:rgba(139,92,246,0.2);padding:4px;border-radius:6px;">ğŸ§—</div>åŠ¨ä½œç»“æ„è´¨é‡ (30%)</div>
                        <div class="metric-score">${Math.round(results.structure.total)}åˆ†</div>
                    </div>
                    <div class="metric-bar-bg"><div class="metric-bar-fill" style="width:0%; background:var(--accent);" data-w="${results.structure.total}%"></div></div>
                    <div class="sub-metric">ä¸‰ç‚¹æ”¯æ’‘: ${results.structure.threePoint}åˆ† (ç¨³å®š${m.stableFrames}å¸§/çŸ­æš‚å¤±è¡¡${m.briefUnstableFrames}å¸§/æŒç»­å¤±è¡¡${m.unstableFrames}å¸§)</div>
                    <div class="sub-metric">è½¬æ¢åˆç†: ${results.structure.conversion}åˆ† (è¿è§„${m.conversionViolations}æ¬¡)</div>
                </div>
                
                <div class="metric">
                    <div class="metric-header">
                        <div class="metric-name"><div style="background:rgba(139,92,246,0.2);padding:4px;border-radius:6px;">âš–ï¸</div>èº«ä½“æ§åˆ¶èƒ½åŠ› (30%)</div>
                        <div class="metric-score">${Math.round(results.control.total)}åˆ†</div>
                    </div>
                    <div class="metric-bar-bg"><div class="metric-bar-fill" style="width:0%; background:var(--accent);" data-w="${results.control.total}%"></div></div>
                    <div class="sub-metric">é‡å¿ƒç¨³å®š: ${results.control.stability}åˆ† (æŠ–åŠ¨${m.instabilityFrames}å¸§)</div>
                    <div class="sub-metric">å¤±è¡¡æ¢å¤: ${results.control.recovery}åˆ† (å¹³å‡æ¢å¤${m.recoveryTimes.length > 0 ? (m.recoveryTimes.reduce((a,b)=>a+b,0)/m.recoveryTimes.length).toFixed(2) : 0}s)</div>
                </div>
                
                <div class="metric">
                    <div class="metric-header">
                        <div class="metric-name"><div style="background:rgba(139,92,246,0.2);padding:4px;border-radius:6px;">ã€°ï¸</div>åŠ¨ä½œæ•ˆç‡ (25%)</div>
                        <div class="metric-score">${Math.round(results.efficiency.total)}åˆ†</div>
                    </div>
                    <div class="metric-bar-bg"><div class="metric-bar-fill" style="width:0%; background:var(--accent);" data-w="${results.efficiency.total}%"></div></div>
                    <div class="sub-metric">åŠ¨ä½œæµç•…: ${results.efficiency.flow}åˆ† (åœé¡¿${m.pauseCount}æ¬¡/å…±${m.totalPauseDuration.toFixed(1)}s)</div>
                    <div class="sub-metric">é¢„æ‘†èƒ½åŠ›: ${results.efficiency.prep}åˆ† (${m.movementCount > 0 ? Math.round((1-m.noPrepCount/m.movementCount)*100) : 0}%çš„æ¢ç‚¹æœ‰é¢„æ‘†)</div>
                </div>
                
                <div class="metric">
                    <div class="metric-header">
                        <div class="metric-name"><div style="background:rgba(139,92,246,0.2);padding:4px;border-radius:6px;">ğŸ”’</div>æŠ€æœ¯é£é™© (15%)</div>
                        <div class="metric-score">${Math.round(results.techniqueRisk.total)}åˆ†</div>
                    </div>
                    <div class="metric-bar-bg"><div class="metric-bar-fill" style="width:0%; background:var(--accent);" data-w="${results.techniqueRisk.total}%"></div></div>
                    <div class="sub-metric">é”è‡‚æ£€æµ‹: ${results.techniqueRisk.lockArm}åˆ† (ç´¯è®¡${m.lockDuration.total.toFixed(1)}s/${m.lockEvents.length}æ¬¡äº‹ä»¶)</div>
                </div>
            `;

            setTimeout(() => {
                document.querySelectorAll('.metric-bar-fill').forEach(b => b.style.width = b.dataset.w);
            }, 300);

            document.getElementById('scoreCard').style.display = 'block';
            window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
        }
    </script>
</body>
</html>